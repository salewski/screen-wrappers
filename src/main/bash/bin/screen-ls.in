#! @BASH_SH@ -
# @configure_input@
#
# Copyright (C) 2013, 2016, 2017 Alan D. Salewski <salewski@att.net>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#
# screen-ls: Pretty-prints the output from 'screen -ls' on stdout. Prints the
# session names (without the leading pid and '.'  char) from the output of the
# 'screen -ls' command. With the '-l' ('--long') option, will print the full
# output in a readable table. With the '-p' ('--show-pid') option, will
# include the pid and '.' char which are suppressed by default.
#
# Any options not recognized by 'screen-ls' will be passed through to
# 'screen'. You can explicitly stop 'screen-ls' options processing by using
# the '--' psueo-option; all options after that will be passed through to
# 'screen'.
#
# See screen-ls(1) for the full story (or run the 'perldoc' program on this
# file).
#
# Exit status will be zero upon success, non-zero upon error (invalid
# arguments provided to this program, for example).

declare -r PROG='screen-ls'

declare -r COPYRIGHT_DATES='2013, 2016, 2017'

declare -r gl_maintainer_addr='@DFLT_MAINTAINER@'  # filtered in at build time

# This variable is replaced by the current screen-wrappers project version
# number at build time.
declare -r SCREEN_WRAPPERS_VERSION='@VERSION@'

# This variable is replaced at build time
declare -r gl_const_build_date='@BUILD_DATE@'
declare -r gl_const_release="${SCREEN_WRAPPERS_VERSION}  (built: ${gl_const_build_date})"


declare -r PROG_SCREEN='@SCREEN@'  # GNU 'screen' command found at configure time

declare -r PROG_COLUMN='@COLUMN@'  # BSD 'column' command found at configure time

# mode flags
declare gl_be_verbose=false       # Boolean. See -v switch.

declare opt_show_long=false       # Dflt; override via the -l switch
declare opt_show_pid=false        # Dflt; override via the -p switch
declare opt_show_sorted=true      # Dflt; override via the -U switch

# This gets set from f_is_screen_4_dot_3_or_newer()
#
# FIXME: Create function to set this explicitly, and then use the value set as
#        a parameter to f_is_screen_4_dot_3_or_newer()
#
declare SCREEN_VERSION_STRING=

declare -a F_CLEANUP_HOOK_NAMES=()

function f_add_cleanup_hook_name () {
    F_CLEANUP_HOOK_NAMES+=( $1 );
}


function f_cleanup () {

    if test ${#F_CLEANUP_HOOK_NAMES[@]} -eq 0; then
        # No cleanup hooks, so nothing to do
        return
    fi

    local cleanup_hook
    local idx

    let idx=${#F_CLEANUP_HOOK_NAMES[@]}-1

    # Note that we're running the cleanup hooks in opposite order from which
    # they were installed.
    #
    while test $idx -ge 0; do

        cleanup_hook=${F_CLEANUP_HOOK_NAMES[$idx]}

        if $gl_be_verbose; then
            printf "${PROG} (info): running cleanup hook: [%s]\n" "${cleanup_hook}" 1>&2
        fi

        test -n "$cleanup_hook" && eval "$cleanup_hook"

        let idx=$idx-1
    done
}

function f_cleanup_and_die () {
    f_cleanup
    exit 1
}

trap 'printf "$PROG (warn): HUP signal caught; bailing out\n"  1>&2; f_cleanup_and_die' HUP
trap 'printf "$PROG (warn): INT signal caught; bailing out\n"  1>&2; f_cleanup_and_die' INT
trap 'printf "$PROG (warn): QUIT signal caught; bailing out\n" 1>&2; f_cleanup_and_die' QUIT
trap 'printf "$PROG (warn): TERM signal caught; bailing out\n" 1>&2; f_cleanup_and_die' TERM

trap 'f_cleanup' EXIT


# This is a list of command line arguments that we'll "pass through" to the
# screen(1) program. Note that if a screen-ls option name clashes with a
# screen(1) opt, the user can specify '--' in front of the options intended
# for screen-ls(1) and we'll pass those through (because we stop processing
# option once we encounter '--')
declare -a ARGS_FOR_SCREEN=()


f_print_help () {

    cat <<EOF
usage: $PROG [OPTION...]
Pretty-prints the output from 'screen -ls' on stdout.

  -h, --help      Print this help message on stdout
  -l, --long      Use long listing format
  -p, --show-pid  Shows the '<pid>.' prefix in screen(1) session names
  -U, --unsorted  Do not sort; list screen sessions in order output by screen(1)
  -V, --version   Print the version of the program on stdout
  -v, --verbose   Tell what is being done. Two or more -v options turns on tracing (set -x)

      --          Signals the end of options and disables further options processing. All
                    remaining arguments will be passed through to screen(1)

Any provided options that are not recognized by $PROG (that is, any
options that are not in the above list) will be passed through to screen(1).

Report bugs to ${gl_maintainer_addr}
EOF
}

f_print_version () {
    cat <<EOF
${PROG} ${gl_const_release}

Copyright (C) ${COPYRIGHT_DATES} Alan D. Salewski <salewski@att.net>
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EOF
}


# Prints on stdout 'true' or 'false' to indicate whether or not the GNU screen
# version being used is 4.3.0 or newer. The value can be captured by callers
# and later used to invoke either the 'true' or 'false' commands.
#
# The return status of the function will be 0 upon success (regardless of
# whether 'true' or 'false' was printed to stdout), and non-zero upon error.
#
# Callers must check the return status. A non-zero return status indicates an
# unexpected processing error.

f_is_screen_4_dot_3_or_newer () {

    local __t_required_count=1
    local __t_minimal_count=1
    local __t_maximal_count=1

    if test $# -lt ${__t_required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; (at least) %d required; bailing out\n" \
            $# ${__t_minimal_count} 1>&2
        exit 1
    fi

    if test $# -gt ${__t_maximal_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; (at most) %d expected; bailing out\n" \
            $# ${__t_maximal_count} 1>&2
        exit 1
    fi

    local __t_fpath_prog_screen
    local __t_screen_version_number_snippet

    __t_fpath_prog_screen=$1


    # Examples of how GNU screen advertizes its version:
    #
    #     Screen version 4.00.03jw4 (FAU) 2-May-06
    #     Screen version 4.03.01 (GNU) 28-Jun-15

    # XXX: This could fail on some mutant compilation of GNU screen
    #
    __t_screen_version_number_snippet=$( "${__t_fpath_prog_screen}" --version \
                                         | head -n 1 \
                                         | sed -n -e 's#^[^[:digit:].]\{1,\}\([[:digit:]]\{1,\}[.][[:digit:]]\{1,\}[.][[:digit:]]\{1,\}\).*#\1#p' )

    if test $? -ne 0; then
        return 1  # error
    fi

    # FIXME: Pass this value in as a parameter
    SCREEN_VERSION_STRING=${__t_screen_version_number_snippet}

    local __t_local_major
    local __t_local_minor

    # Digits through the first dot are the major version number
    #
    __t_local_major=$(echo "${__t_screen_version_number_snippet}" | sed -n -e 's#^\([^.]\{1,\}\)[.].*#\1#p')

    if test -z "${__t_local_major}"; then
        printf "${PROG} (warning): was unable to determine the major version number of screen\n" 1>&2
        return 1  # false
    fi

    # Digits between the first and second dot are the minor version number
    #
    __t_local_minor=$(echo "${__t_screen_version_number_snippet}" | sed -n -e 's#^[^.]\{1,\}[.]\([[:digit:]]\{1,\}\)[.].*#\1#p')

    if test -z "${__t_local_minor}"; then
        printf "${PROG} (warning): was unable to determine the minor version number of screen\n" 1>&2
        return 1  # false
    fi

    # The MAJOR.MINOR.REVISION numbers reported by 'screen --version'
    # typically contain leading zeros which would cause the decimal numbers to
    # be interpretted as octal numbers. We'll slice off the leading zeroes to
    # avoid that by explicitly telling the shell that we want the base 10
    # values.
    __t_local_major=$((10#${__t_local_major}))
    __t_local_minor=$((10#${__t_local_minor}))

    # Note that there's a third 'revision' component to the advertized GNU
    # screen version number that we're ignoring here. We'll return a success
    # status for any version greater than or equal to 4.3.0.

    if test ${__t_local_major} -ge 4 \
    && test ${__t_local_minor} -ge 3; then
        printf 'true\n'
        return 0  # success; found version of screen is 4.3.0 or newer
    fi

    printf 'false\n'
    return 0  # success; found version of screen is older than 4.3.0
}


pos_last_plus_one=$(( $# + 1 ))

# Each value is one or zero, which indicates whether or not the option is
# expected to have an argument.
#
declare -A longopt_spec=(
    ['help']=0      # -h
    ['version']=0   # -V

    ['long']=0      # -l
    ['show-pid']=0  # -p
    ['unsorted']=0  # -U
    ['verbose']=0   # -v
)

# internal sanity check
for one_key in "${!longopt_spec[@]}"; do
    one_val=${longopt_spec[${one_key}]}
    if [[ $one_val =~ ^[01]$ ]]; then :; else
        printf "${PROG} (BUG) [line $LINENO]: value (%s) for longopt key '%s' must be either 0 or 1; bailing out\n" \
               "${one_val}" "${one_key}" 1>&2
        exit 1
    fi
done

if test $# -gt 0; then

    # Using getopts in "silent mode". Note that adding '-' to the optstring allows us to
    # process GNU-style long-form options; that option is specified to take an argument to
    # cause getopts to place whatever follows the second '-' character into OPTARG.
    #
    # Note that getopts will automatically stop processsing options upon encountering
    # '--', but we still need to deal with the pathological form --=BLAH (no option name,
    # just a value using the equals-sign syntax).
    #
    while getopts ':-:hlpUVv' opt
    do
        : $PROG \(trace: $LINENO\): opt is: $opt

        if test "${opt}" = '-'; then

            # Intercepting processing of long-form option. This conditional
            # block will set up the 'opt', 'OPTARG', and 'OPTIND' variables for
            # the code that follows, just as if getopts had the capability to
            # process long-form options.

            # OPTARG here is one of:
            #
            #     =BLAH    (which means user specified '--=BLAH')
            # or:
            #     foo
            # or:
            #     foo=FOOVAL

            if [[ ${OPTARG} =~ .*=.* ]]; then

                : $PROG \(trace: $LINENO\): OPTARG is name=value style

                # Keep everything up to the first '=' sign. Note that if the
                # option was specified as: --foo=FOOVAL, then $opt here will be
                # 'foo' (no hyphen chars).
                opt=${OPTARG/=*/}
                : $PROG \(trace: $LINENO\): opt is: $opt

                : $PROG \(trace: $LINENO\): a long option name must be at least two characters in length
                if test ${#opt} -le 1; then
                    printf "${PROG} (error): invalid long option '%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else

                    # Unrecognized option; we'll pass it through to screen(1). Note that
                    # we need to restore the leading '-' that getopts has sliced off.
                    #
                    ARGS_FOR_SCREEN[${#ARGS_FOR_SCREEN[@]}]="-${OPTARG}"
                    continue
                fi

                # Since we know the option was specified in --foo=BAR form, the
                # option was specified erroneously unless the option's long-form
                # spec indicates that it can accept an argument.
                #
                if test ${longopt_spec[${opt}]} -ne 1; then
                    printf "${PROG} (error): option '%s' does not take an argument; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                OPTARG=${OPTARG#*=}  # keep everything after the first '=' sign
                : $PROG \(trace: $LINENO\): OPTARG is: $OPTARG

            else
                : $PROG \(trace: $LINENO\): OPTARG is name-only style

                opt="$OPTARG"
                : $PROG \(trace: $LINENO\): opt is: $opt

                if test -z "${opt}"; then

                    # This should be a "can't happen" scenario; since bash's 'getopts'
                    # implementation should directly handle the magic '--' token, we
                    # should never fall through here.

                    printf "${PROG} (BUG) [line $LINENO]: received empty OPTARG, which means getopts did not handle the stand-alone '--' token; bailing out\n" 1>&2
                    exit 1
                fi

                : $PROG \(trace: $LINENO\): a non-empty long option name must be at least two characters in length
                if test ${#opt} -lt 2; then
                    printf "${PROG} (error): invalid long option '%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else

                    # Unrecognized option; we'll pass it through to screen(1). Note that
                    # we need to restore the leading '-' that getopts has sliced off.
                    #
                    ARGS_FOR_SCREEN[${#ARGS_FOR_SCREEN[@]}]="-${OPTARG}"
                    continue
                fi

                # We know the option was specified in one of the following forms:
                #
                #     --foo
                # or:
                #     --foo FOOVAL
                #
                # The option's long-form spec will tell us whether or not an argument is
                # expected for the option.
                #
                if test ${longopt_spec[${opt}]} -eq 1; then

                    # If bumping OPTIND would put us more than one beyond the "last pos
                    # plus one", then there is no argument provided at position OPTIND for
                    # us to consume.
                    #
                    if (( $(( $OPTIND + 1 )) > pos_last_plus_one )); then

                        printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                        f_print_help 1>&2
                        exit 1
                    fi

                    OPTARG=${@:${OPTIND}:1}
                    (( ++OPTIND ))
                    : $PROG \(trace: $LINENO\): manually incremented OPTIND to: $OPTIND
                fi
            fi
        fi

        # Normal getopts style processing happens beneath here, with the slight
        # twist that 'opt' may contain a long-form option name.

        case $opt in

            'help' | 'h' )
                # print help message
                f_print_help
                exit 0
                ;;


            'long' | 'l' )
                opt_show_long=true
                ;;


            'show-pid' | 'p' )
                opt_show_pid=true
                ;;


            'unsorted' | 'U' )
                opt_show_sorted=false
                ;;


            'version' | 'V' )
                # print program version info
                f_print_version
                exit 0
                ;;


            'verbose' | 'v' )
                # Accumulating 'verbose' opt. A single -v opt simply turns $gl_be_verbose
                # on; two or more '-v' opts turns tracing on. Note that if you intend to
                # turn tracing on, you'll probably want your -v opts to be the first opts
                # on the command line (so they take effect earlier).
                #
                if $gl_be_verbose; then
                    # We've seen at least one -v opt before, so now we're turning tracing on
                    set -x
                else
                    # First -v opt we're seeing
                    gl_be_verbose=true
                fi
                ;;


            ':')  # getopts put : in opt
                  # Note that we need to restore the leading '-' that getopts
                  # has sliced off.
                  printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            '?')  # getopts put ? in opt
                  # Unrecognized option; we'll pass it through to screen(1). Note that we
                  # need to restore the leading '-' that getopts has sliced off.
                  ARGS_FOR_SCREEN[${#ARGS_FOR_SCREEN[@]}]="-${OPTARG}"
                  ;;

            * )   printf "${PROG} (BUG) [line $LINENO]: unhandled option case; opt: '$opt',  OPTARG: '$OPTARG'\n" 1>&2
                  ;;

        esac
    done
fi

# shift off all arguments already handled
let ii=1;  # shell OPTIND index starts at 1
while (( ii < ${OPTIND} )); do
    shift
    (( ++ii ))
    : $PROG \(trace: $LINENO\): ii is now: $ii
done

# Drain any remaining command line parameters not processed by getopts and add them to the
# list that we will pass through to screen(1):
while test $# -gt 0; do
    ARGS_FOR_SCREEN[${#ARGS_FOR_SCREEN[@]}]=$1
    shift
done


# Effectively a NOOP. Yes, arguably a UUoC, but useful because we're composing
# pipelines. If you know of a better way to do this, please speak up!
declare -r NOOP='cat -'  

chop_pid_command='sed -e ''s/^[[:space:]]*[[:digit:]]\{1,\}[.]//'

if $opt_show_pid; then
    chop_pid_command=$NOOP
fi


if $opt_show_long; then
    sed_or_column_command="${PROG_COLUMN}"' -t'
fi


# XXX: We're using any old 'sort' command here, which is good for
#      portability. However, maybe consider adding optional support (detected
#      at configure time) of a sort (such as GNU sort) that recognizes the
#      '--stable' option.
#
maybe_sort_command=$NOOP  # Represents '-U' (--unsorted) behavior
if $opt_show_sorted; then

    maybe_sort_command='sort -k1,1'  # sorting by screen session name when no pid prefix is present

    if $opt_show_pid; then

        # Sorting by screen session name when the pid prefix is present. Input
        # lines will start with values that look like:
        #
        #     779.screen-wrappers-dev
        #     14926.emacs-dev
        #
        # so we have to tell sort to "skip over" the pid portion.
        #
        maybe_sort_command='sort -t. -k2,2'  
    fi
fi

# The 'screen' program prior to version 4.0.3 (from 2015-06-12, advertized as
# '4.03.00' by 'screen --version') has a bug that causes the 'screen -ls'
# command to exit with status 1 upon success.
#
# For info on the upstream bug see:
#
#     http://savannah.gnu.org/bugs/?26750
#
# We want to work with either version, though, so we'll dynamically test the
# major.minor version numbers and adjust our behavior accordingly.
#
# FIXME: go (need an invocation in the current process to set SCREEN_VERSION_STRING)
f_is_screen_4_dot_3_or_newer "${PROG_SCREEN}" > /dev/null
if test $? -ne 0; then
    printf "${PROG} (error): was unable to set the version string for the available GNU screen program: \"%s\"; bailing out\n" \
           "${PROG_SCREEN}" 1>&2
    exit 1
fi
# FIXME: end
have_screen_4_dot_3_or_newer=$(f_is_screen_4_dot_3_or_newer "${PROG_SCREEN}")
if test $? -ne 0; then
    printf "${PROG} (error): was unable to obtain the version of the available GNU screen program: \"%s\"; bailing out\n" \
           "${PROG_SCREEN}" 1>&2
    exit 1
fi
#
# CAREFUL: The value of SCREEN_LS_ESTAT should match the value here only when
#          'screen -ls' is invoked and there is a matching socket (that, only
#          when there is one or more existing screen sessions).
#
#          When 'screen -ls' is invoked and there are no existing screen
#          sessions, the expected exit status is 1 for all versions of screen
#          the author has tested.
#
#          Note, too, that the '-q' option changes the meanings of the exit
#          status codes; see screen(1) and comments elsewhere in this file for
#          more info on that.
#
if $have_screen_4_dot_3_or_newer; then
    SCREEN_LS_ESTAT=0
else
    SCREEN_LS_ESTAT=1
fi

# From screen(1)  [screen version 4.00.03 (FAU) 23-Oct-06]:
# <quote>
#      -q   Suppress printing of error messages. In combination with "-ls" the
#           exit  value  is  as  follows: 9 indicates a directory without ses-
#           sions. 10 indicates a directory with running  but  not  attachable
#           sessions.  11 (or more) indicates 1 (or more) usable sessions.  In
#           combination with "-r" the exit value is as follows:  10  indicates
#           that  there  is  no session to resume. 12 (or more) indicates that
#           there are 2 (or more) sessions to resume and  you  should  specify
#           which one to choose.  In all other cases "-q" has no effect.
# </quote>
#
# [Note that the man page text for the option remains identical to the above
# as of screen version 4.05.00 (GNU) 10-Dec-16]
#
# That means that if we are careful, we can use the exit status directly to
# determine whether or not the user has any screen sessions:
#
#         9 means "no screen sessions"
#
#    10-125 means "at least one session" (bash(1) (section "EXIT STATUS")
#           documents special use of exit statuses greater than 125, so we
#           will only consider values greater than 10 but less than 125 as
#           having been produced directly by 'screen'. Note that we are only
#           concerned with the presence or non-presence of screen sessions;
#           this program does not care whether or not the sessions are usable
#           or resumable. If there are screen sessions present, we will report
#           on their presence.
#
declare -r -i SCREEN_Q_LS_ESTAT_NO_SCREEN_SESSIONS=9
# declare -r -i SCREEN_Q_LS_ESTAT_SCREEN_SESSIONS_PRESENT_MIN=10
declare -r -i SCREEN_Q_LS_ESTAT_SCREEN_SESSIONS_PRESENT_MAX=125
#
#
# The layout of the 'screen -q -ls' exit status codes allows us to consider a
# solid range of values as indicating command invocation "success":
declare -r -i SCREEN_Q_LS_ESTAT_SUCCESS_MIN=${SCREEN_Q_LS_ESTAT_NO_SCREEN_SESSIONS}
declare -r -i SCREEN_Q_LS_ESTAT_SUCCESS_MAX=${SCREEN_Q_LS_ESTAT_SCREEN_SESSIONS_PRESENT_MAX}


# GitHub issue #7 note: Different versions of 'screen' produce different
# output, so our regexen below try to be flexible enough to accommodate all of
# the variations known to the screen-wrappers author. If you encounter a
# different variation than those supported here, the result will likely be
# that screen-ls swallows all of the output from the 'screen -ls' command (so
# it will be obvious that there is a problem); please let the screen-wrappers
# author know!
#
# Examples of known output formats:
#
#             28189.screen-wrappers-hacking   (Attached)
#
#             28189.screen-wrappers-hacking   (06/22/2016 06:49:18 PM)        (Attached)
#

# Matches:
#             28189.screen-wrappers-hacking   (Attached)
#
# Note that we always need to have 3 capture groups, so we have an empty
# capture group in our expression here (where the date info is located in the
# output of newer versions of screen).
#
re_chunks_type_005='^[[:space:]]*([^[:space:]].*)[[:space:]]{1,}()([(][^)]{1,}[)])[[:space:]]*$'

# Matches:
#             28189.screen-wrappers-hacking   (06/22/2016 06:49:18 PM)        (Attached)
#
re_chunks_type_010='^[[:space:]]*([^[:space:]].*)[[:space:]]{1,}([(][^)]{1,}[)])[[:space:]]{1,}([(][^)]{1,}[)])[[:space:]]*$'

# This will be assigned to a regex captures the three fields of interest. The
# first time through one of the below two loops we will have to try various
# flavors of the regex, but once we've identified the type of 'screen -ls'
# output that we are dealing with we use the correct regex directly.
#
re_chunks=


# When running 'screen -ls', the first line of output on stdout (when there
# are no active screen sessions) will have this form:
#
#     No Sockets found in /run/screen/S-${USER}.
#
re_no_sockets_found_loose='No[[:space:]]{1,}Sockets[[:space:]]{1,}found'
re_no_sockets_found_tight='^'"${re_no_sockets_found_loose}"



# The user would have to have a really pathological situation for the output
# from 'screen -ls' to be large enough that we could not easily hold it all in
# memory (if that describes you, though, then let the author know!).
#
# CAREFUL: Empirical testing (on screen version 4.00.03 (FAU) 23-Oct-06 and
#          screen version 4.05.00 (GNU) 10-Dec-16) reveals that the '-q'
#          option must come first for screen to exhibit the desired behavior
#          of exiting with meaningful exit statuses when combined with the
#          '-ls' option. In the author's testing, specifying the '-q' option
#          second causes screen to exit with status 1 and otherwise behave in
#          unexpected (and obviously incorrect) ways.
#
DATA_SCREEN_Q_LS_OUTPUT=$("${PROG_SCREEN}" -q -ls "${ARGS_FOR_SCREEN[@]}")
t_screen_q_ls_estat=$?

# Per the commentary above, we are expecting the 'screen -q -ls' exit status
# to be within a range of values (between 9 and 125) for any type of
# successful outcome.
if test ${t_screen_q_ls_estat} -lt ${SCREEN_Q_LS_ESTAT_SUCCESS_MIN} \
|| test ${t_screen_q_ls_estat} -gt ${SCREEN_Q_LS_ESTAT_SUCCESS_MAX}; then

    printf "${PROG} (error): was unable to execute 'screen -q -ls' (exit status was %d): bailing out\n" ${t_screen_q_ls_estat} 1>&2

    exit 1  # explicitly exit with status 1 (rather than ${SCREEN_Q_LS_ESTAT}
            # itself, as there is a non-zero chance that some future change in
            # screen behavior would cause it to exit with status zero here).
fi

: $PROG \(trace: $LINENO\): testing 'screen -q -ls' exit status \(${t_screen_q_ls_estat}\) against SCREEN_Q_LS_ESTAT_NO_SCREEN_SESSIONS \(${SCREEN_Q_LS_ESTAT_NO_SCREEN_SESSIONS}\)
if test ${t_screen_q_ls_estat} -eq ${SCREEN_Q_LS_ESTAT_NO_SCREEN_SESSIONS}; then

    : $PROG \(trace: $LINENO\): exit status of 'screen -q -ls' \(${t_screen_q_ls_estat}\) indicates that there are no existing screen sessions

    if $gl_be_verbose; then
        printf "${PROG} (info): no screen sessions exist (okay); exiting early with success status (no work left to do)\n" 1>&2
    fi

    exit 0
fi

unset t_screen_q_ls_estat


# If we are falling through here then we think there is one or more screen
# sessions to show the user. We will collect the output from 'screen -ls' and
# parse it to show the appropriate data to the end user.
#
# Note that there is an inherent race condition between our two invocations of
# 'screen' (our above 'screen -q -ls' invocation and our below 'screen -ls'
# invocation). We try to paper over any issues (e.g., all screen sessions
# having gone away) by parsing for the "no screen sessions available"
# scenario, even though we accounted for that in a more direct way above.


DATA_SCREEN_LS_OUTPUT=$("${PROG_SCREEN}" -ls "${ARGS_FOR_SCREEN[@]}")
t_screen_ls_estat=$?
# if test ${t_screen_ls_estat} -ne ${SCREEN_LS_ESTAT}; then  # screen prior to 4.3.0 exits with status 1; later versions exit with status 0 (as expected). We'll work with either.
if test ${t_screen_ls_estat} -ne 0 \
&& test ${t_screen_ls_estat} -ne 1; then  # screen prior to 4.3.0 exits with status 1; later versions exit with status 0 (as expected). We'll work with either.

    printf "${PROG} (error): was unable to execute 'screen -ls': bailing out\n"  1>&2
    exit 1
fi


# XXX: It is conceivable that some future version of screen(1) might emit no
#      output for 'screen -ls' when the user has no screen sessions, but that
#      is not the case currently. This check will help us detect such behavior
#      changes and give us direct feedback about it (so the author can adjust
#      the behavior of this program accordingly). For the foreseeable future,
#      this should never happen...
if test -z "${DATA_SCREEN_LS_OUTPUT}"; then
    printf "${PROG} (BUG?): 'screen -ls' exited successfully, but produced no output (???): bailing out\n"  1>&2
    exit 1
fi

# We do the following check in two steps even though it could more efficiently
# be performed in one. The idea is that trace-level debugging will help us
# detect future behavior changes in which legit "No Sockets found" messages
# appear someplace other than anchored to the beginning of the first line of
# stdout.
#
if [[ "${DATA_SCREEN_LS_OUTPUT}" =~ $re_no_sockets_found_loose ]]; then

    # A "No Sockets found" type of string was found in the output of the
    # 'screen -ls' command, but we do not yet know whether or not it is
    # indicative of an unfortunate screen session name (see below comments) or
    # a legit scenario in which the user simply does not have any screen
    # sessions active.
    #
    # Even if the user does something pathological such as:
    #
    #     $ screen -S 'No Sockets found'
    #
    # the output of 'screen -ls' is expected to be such that the screen
    # session names are /not/ named on the first line of its output:
    #
    #     $ screen -ls
    #     There are screens on:
    #             19185.No Sockets found  (05/14/2017 12:35:33 PM)        (Attached)
    #
    # We should therefore be safe checking for the "No Sockets found" type of
    # message on the first line and using that to differentiate between the
    # two scenarios.
    #
    : $PROG \(trace: $LINENO\): checking for "No Sockets found" type of message on first line of 'screen -ls' output.

    t_first_line=$( builtin echo "${DATA_SCREEN_LS_OUTPUT}" | head -n 1)
    if test $? -ne 0; then
        printf "${PROG} (error): was unable to isolate first line of 'screen -ls' output: bailing out\n"  1>&2
        exit 1
    fi

    if [[ "${t_first_line}" =~ $re_no_sockets_found_tight ]]; then

        # Sanity check: Both old (4.3.0) and newer (4.5.0) versions of screen
        # exit with status 1 for 'screen -ls' when there are no screen
        # sessions available. If this changes, we want to know about it as it
        # might invalidate some of the decisions made by this program.
        if test ${t_screen_ls_estat} -ne 1; then
            printf "${PROG} (warning) 'screen -ls' indicates no screen sessions, but exited with status %d (expected status 1); continuing anyway\n" "${t_screen_ls_estat}" 1>&2
            # Keep going...
        fi

        : $PROG \(trace: $LINENO\): output text of 'screen -ls' \(${t_screen_ls_estat}\) indicates that there are no existing screen sessions

        if $gl_be_verbose; then
            printf "${PROG} (info): no screen sessions exist (okay); exiting early with success status (no work left to do)\n" 1>&2
        fi
        exit 0
    fi
    unset t_first_line
fi

# If we are falling through here, we expect that there is at least one active
# screen session. That means that ${t_screen_ls_estat} should match
# ${SCREEN_LS_ESTAT}, too.
#
: $PROG \(trace: $LINENO\): expecting there is at least one active screen session\; checking t_screen_last_estat \(${t_screen_last_estat}\) against SCREEN_LS_ESTAT \(${SCREEN_LS_ESTAT}\)
#
if test ${t_screen_ls_estat} -ne ${SCREEN_LS_ESTAT}; then  # screen prior to 4.3.0 exits with status 1; later versions exit with status 0 (as expected). We'll work with either.

    printf "${PROG} (error): detected existing screen sessions, but exit status of 'screen -ls' was %d (expected %d from installed screen version %s): bailing out\n" \
           "${t_screen_ls_estat}"     \
           "${SCREEN_LS_ESTAT}"       \
           "${SCREEN_VERSION_STRING}" \
           1>&2
    exit 1
fi
unset t_screen_ls_estat

if $opt_show_long; then

    builtin echo "${DATA_SCREEN_LS_OUTPUT}" \
    | tail -n +2 \
    | head -n -2 \
    | $chop_pid_command \
    | while read -r line; do

          : $PROG \(trace: $LINENO\): line: "$line"

          if test -z "${re_chunks}"; then

              # CAREFUL: Order of the regex tests is important
              #
              if   [[ "$line" =~ $re_chunks_type_010 ]]; then
                  re_chunks=$re_chunks_type_010

              elif [[ "$line" =~ $re_chunks_type_005 ]]; then
                  re_chunks=$re_chunks_type_005

              else
                  printf "${PROG} (error): unrecognized output from 'screen -ls':\n    \"%s\"\nBailing out\n" "$line" 1>&2
                  exit 1
              fi
          else
              if [[ "$line" =~ $re_chunks ]]; then :; else
                  printf "${PROG} (error): unrecognized output from 'screen -ls':\n    \"%s\"\nBailing out\n" "$line" 1>&2
                  exit 1
              fi
          fi

          t_session_name=${BASH_REMATCH[1]}   # may contain spaces
          t_session_date=${BASH_REMATCH[2]}   # will be empty if output is from an older version of screen
          t_session_state=${BASH_REMATCH[3]}  # '(Attached)', '(Detached)', ...

          # Recall that 0x1f is the ASCII "unit separator" character; used
          # here because it is exceedingly unlikely to appear in the output of
          # 'screen -ls'. That is the hope, at least...
          #
          # From ascii(7):
          #     Oct   Dec   Hex   Char
          #     ──────────────────────────────────────
          #     ...
          #     034   28    1C    FS  (file separator)
          #     035   29    1D    GS  (group separator)
          #     036   30    1E    RS  (record separator)
          #     037   31    1F    US  (unit separator)
          #     ...
          #
          # The rationale is that screen(1) session names may contain spaces
          # in them, so we need to doctor-up the input to column(1) to allow
          # it to definitively distinguish which values belong in which
          # column.
          #
          printf '%s%s%s%s%s%s\n' \
              "${t_session_name}"  $'\x1f' \
              "${t_session_date}"  $'\x1f' \
              "${t_session_state}" $'\x1f'
      done \
    | $maybe_sort_command \
    | "${PROG_COLUMN}" -s $'\x1f' -t

    # Note that we can't use bash's 'pipefail' option because 'screen -ls' (at
    # least as of the 4.01.00devel version shipped with Debian) exits with
    # non-zero status upon success. There's an open (as of 2013-07-08) issue
    # for this filed in the upstream issue tracker for this behavior:
    #
    #     http://savannah.gnu.org/bugs/?26750
    #
    # It's been open since 2009, though, so maybe isn't easy to fix...
    #
    # In any event, we'll need to check the exit status of each command in the
    # pipeline individually using the PIPESTATUS array.

    declare -a t_estat_arr=( ${PIPESTATUS[@]} )

    test ${t_estat_arr[0]} -eq 0 &&  # builtin echo
    test ${t_estat_arr[1]} -eq 0 &&  # tail
    test ${t_estat_arr[2]} -eq 0 &&  # head
    test ${t_estat_arr[3]} -eq 0 &&  # $chop_pid_command
    test ${t_estat_arr[4]} -eq 0 &&  # while loop
    test ${t_estat_arr[5]} -eq 0 &&  # $maybe_sort_command
    test ${t_estat_arr[6]} -eq 0 ||  # ${PROG_COLUMN}
    {
        printf "${PROG} (error): was error while processing output of 'screen -ls' command; PIPESTATUS: %s %s %s %s %s %s; bailing out\n" "${t_estat_arr[@]}" 1>&2
        exit 1
    }

else

    # Note that our bash regexen below keep all tokens of the session name (it
    # may contain spaces; see notes above) by definitively matching the date
    # and session state tokens at the end of each line of 'screen -ls' output,
    # and then keeping everything that appears in front of them.

    builtin echo "${DATA_SCREEN_LS_OUTPUT}" \
    | grep '^[[:space:]]\{1,\}[^[:space:]]' \
    | $chop_pid_command \
    | while read -r line; do

          : $PROG \(trace: $LINENO\): line: "$line"

          if test -z "${re_chunks}"; then

              # CAREFUL: Order of the regex tests is important
              #
              if   [[ "$line" =~ $re_chunks_type_010 ]]; then
                  re_chunks=$re_chunks_type_010

              elif [[ "$line" =~ $re_chunks_type_005 ]]; then
                  re_chunks=$re_chunks_type_005

              else
                  printf "${PROG} (error): unrecognized output from 'screen -ls':\n    \"%s\"\nBailing out\n" "$line" 1>&2
                  exit 1  # from subshell
              fi
          else
              if [[ "$line" =~ $re_chunks ]]; then :; else
                  printf "${PROG} (error): unrecognized output from 'screen -ls':\n    \"%s\"\nBailing out\n" "$line" 1>&2
                  exit 1  # from subshell
              fi
          fi

          t_session_name=${BASH_REMATCH[1]}   # may contain spaces
          # t_session_date=${BASH_REMATCH[2]}   # will be empty if output is from an older version of screen
          # t_session_state=${BASH_REMATCH[3]}  # '(Attached)', '(Detached)', ...

          printf '%s\n' "${t_session_name}"
      done \
    | $maybe_sort_command

    # See notes above on why we can't use bash's 'pipefail' option, etc.

    declare -a t_estat_arr=( ${PIPESTATUS[@]} )

    test ${t_estat_arr[0]} -eq 0 &&  # builtin echo
    test ${t_estat_arr[1]} -eq 0 &&  # grep
    test ${t_estat_arr[2]} -eq 0 &&  # $chop_pid_command
    test ${t_estat_arr[3]} -eq 0 &&  # while loop
    test ${t_estat_arr[4]} -eq 0 ||  # $maybe_sort_command
    {
        printf "${PROG} (error): was error while processing output of 'screen -ls' command; PIPESTATUS: %s %s %s %s %s; bailing out\n" "${t_estat_arr[@]}" 1>&2
        exit 1
    }

fi

exit 0


# ----------------------------------------------------------------------------
# Documentation
#
# The docs are in Perl's POD format, so you can run either the 'perldoc' or
# 'pod2man' programs on this file to produce a man page.
#
# To generate a man page for distribution (in a tarball, DEB, or RPM, for
# instance), you'll probably want to run pod2man something like this:
#
#     $ pod2man /path/to/this/file \
#               --center='screen-ls' \
#               --release='screen-wrappers-0.1.0' \
#               --section='1' \
#               > /outputdir/screen-ls.1
#
# To inspect the page formatting, etc., you can pipe the above 'pod2man'
# command to:
#     'man -l -'
# instead of redirecting the output to a file.
#
# ----------------------------------------------------------------------------

=pod

=head1 NAME

  screen-ls - pretty-prints the output from 'screen -ls'


=head1 SYNOPSIS

  screen-ls -h
  screen-ls -V
  screen-ls [OPTION...] [--] [SCREEN_OPTIONS]


=head1 DESCRIPTION

The C<screen-ls> program invokes the GNU L<screen(1)> program with the C<-ls>
option to obtain a list of screen session names, and pretty prints the
output. See L</"EXAMPLES"> below.

By default, prints the L<screen(1)> session names (without the leading pid and
C<.> char) from the output of the C<screen -ls> command.

With the C<-l> (C<--long>) option, will print the full output in a readable
table.

With the C<-p> (C<--show-pid>) option, will include the pid and <.> char which
are suppressed by default.

Any options not recognized by C<screen-ls> will be passed through to
L<screen(1)>. You can explicitly stop C<screen-ls> options processing by using
the C<--> pseudo-option; all options after that will be passed through to
L<screen(1)>.


=head2 Motivation

When working with GNU L<screen(1)>, it is not uncommon to accumulate a large
number of L<screen(1)> sessions. This naturally leads to the need to locate
"interesting" sessions at a later time when you wish to reconnect to them.
And that, of course, becomes more difficult as the number of L<screen(1)>
sessions increases.

Pretty-printing the output makes it easier to read by inspection, and
suppressing everything except the L<screen(1)> session names from the output
often simplifies downstream processing in a Unix pipeline.


=head1 OPTIONS

Below are the command line options recognized by C<screen-ls>. Any options not
recognized by C<screen-ls> will be passed through to the L<screen(1)>
subprocess.

You can explicitly stop C<screen-ls> options processing by using the C<-->
pseudo-option; all options after that will be passed through to L<screen(1)>.


=over 4

=item -h, --help

Print help usage message


=item -l, --long

Use a long listing format.


=item -p, --show-pid

Causes C<screen-ls> to display the '<pid>.' prefix in screen session names. By
default, C<screen-ls> suppresses the output of this prefix.


=item -U, --unsorted

Do not sort output; list L<screen(1)> sessions in order output by the C<screen
-ls> subprocess invocation.

By default, C<screen-ls> sorts the output by L<screen(1)> session name; this
is an optimization for the common case. Prior to this behavior, the most
common invocation of C<screen-ls> was:

    $ screen-ls | sort

The C<-U> (C<--unsorted>) option exists to allow you to disable this behavior,
though.


=item -V, --version

Print the version of the program to stdout and then exit.


=item -v, --verbose

Turn on verbose mode. Two or more -v options turns on tracing (invokes C<set
-x>; this is primarily intended for developers).


=back


=head1 EXAMPLES


For reference, the default output of C<screen -ls> might look like this:

    $ screen -ls
    There are screens on:
        779.screen-wrappers-dev (07/08/2013 01:09:19 PM)        (Attached)
        26043.datomic-local     (07/07/2013 02:20:50 PM)        (Attached)
        14926.emacs-dev (06/30/2013 07:57:14 PM)        (Attached)
        24078.activemq-mysql-prod       (06/23/2013 01:22:41 AM)        (Detached)
        803.build-build (05/22/2013 06:02:49 AM)        (Detached)
        12522.release-5.5       (05/18/2013 06:09:31 AM)        (Attached)
        5200.mutt      (05/17/2013 10:21:59 AM)        (Attached)
    ...
    49 Sockets in /var/run/screen/S-ads.

That output is truncated, but you get the idea. When there are only two or
three L<screen(1)> session active, then the default output works
fine. However, when there are a large number of L<screen(1)> sessions active
(such as in above example, where there are 49), it can become difficult to
find the interesting ones. Enter C<screen-ls>.

By default, C<screen-ls> strips away all data except the L<screen(1)> session
name, and it removes the pid and following C<.> character from those, as
well. Here is how the above output appears when generated by C<screen-ls>:

    $ screen-ls
    activemq-mysql-prod
    build-build
    datomic-local
    emacs-dev
    mutt
    release-5.5
    screen-wrappers-dev
    ...

That is both easier to read, and easier to process by downstream tools in a
pipeline.

Note that C<screen-ls> sorted the output by the L<screen(1)> session name
automatically. You can disable the sorting behavior by providing the C<-U>
(C<--unsorted>) option:

    $ screen-ls -U
    screen-wrappers-dev
    datomic-local
    emacs-dev
    activemq-mysql-prod
    build-build
    release-5.5
    mutt
    ...


An example of common usage in a pipeline is to use C<screen-ls> to find a given
L<screen(1)> session, and then use the shell's command recall and command line
editing facilities to feed that found L<screen(1)> session name to
L<screen(1)> in order to reconnect to it. Using our running example, let's say
we want to reconnect to the L<screen(1)> session in which emacs development is
underway. In a POSIX compatible shell, that can be accomplished thus:

    $ screen-ls | grep emacs
    emacs-dev

    $ screen -d -r $(screen-ls | grep emacs)

Using L<bash(1)>, the keystrokes required for that invocation on the author's
machine are:

    s c r TAB - l TAB | g r e p SPACE e m a c s RET

    C-p C-a s c r TAB - d SPACE - r SPACE $ ( C-e ) RET

While that may be tedious to read, it flies off the fingers. Compare that to
accomplishing the same task reliably without C<screen-ls>.

If you have duplicate session names, in order to reconnect to a particular
L<screen(1)> session you will need to specify the C<pid> prefix for the
session name that C<screen-ls> suppresses by default. You can prevent
C<screen-ls> from suppressing this behavior by specifying the C<-p>
(C<--show-pid>) option:

    $ screen-ls -p -U
    779.screen-wrappers-dev
    713.screen-wrappers-dev
    26043.datomic-local
    14926.emacs-dev
    24078.activemq-mysql-prod
    803.build-build
    12522.release-5.5
    5200.mutt
    ...

    $ screen -d -r 713.screen-wrappers-dev


When invoked with the C<-l> (C<--long>) option, C<screen-ls> will print the
C<screen ls> output in a readable table (still sorted by L<screen(1)> session
name):

    $ screen-ls -l
    activemq-mysql-prod  (06/23/2013 01:22:41 AM)  (Detached)
    build-build          (05/22/2013 06:02:49 AM)  (Detached)
    datomic-local        (07/07/2013 02:20:50 PM)  (Attached)
    emacs-dev            (06/30/2013 07:57:14 PM)  (Attached)
    mutt                 (05/17/2013 10:21:59 AM)  (Attached)
    release-5.5          (05/18/2013 06:09:31 AM)  (Attached)
    screen-wrappers-dev  (07/08/2013 01:09:19 PM)  (Attached)
    ...


Of course, to see the C<pid> prefixes on the session names, you would need to
add the C<-p> option to that:

    $ screen-ls -l -p
    24078.activemq-mysql-prod  (06/23/2013 01:22:41 AM)  (Detached)
    803.build-build            (05/22/2013 06:02:49 AM)  (Detached)
    26043.datomic-local        (07/07/2013 02:20:50 PM)  (Attached)
    14926.emacs-dev            (06/30/2013 07:57:14 PM)  (Attached)
    5200.mutt                  (05/17/2013 10:21:59 AM)  (Attached)
    12522.release-5.5          (05/18/2013 06:09:31 AM)  (Attached)
    779.screen-wrappers-dev    (07/08/2013 01:09:19 PM)  (Attached)
    ...

Note that the output is still sorted by the L<screen(1)> session name (as it
exists without the '<pid>.' prefix, the same way you would see it within
L<screen(1)> when output via screen's C<sessionname> command).


=head1 DIAGNOSTICS

Exits with 0 (zero) status on success, nonzero on error.


=head1 BUGS

=over

=item *

Internally checks that the exit status of C<screen -ls> is 1 when it detects
that the underlying C<screen> version is older than C<4.0.3> (released
2015-06-12, advertized as C<4.03.00> by C<screen --version>). Those older
versions have a bug that causes the C<screen -ls> command to exit with status
1 upon success even when existing screen sessions are detected.

For info on the upstream bug see:

    <http://savannah.gnu.org/bugs/?26750>

See comments in C<screen-ls> source code for more details (HINT: grep for
C<SCREEN_LS_ESTAT>).

=back

If you find any others, please send a bug report to the author. See
L</"AUTHOR">


=head1 AUTHOR

Written by Alan D. Salewski <salewski@att.net>.


=head1 CONTRIBUTORS

    John Marquart (jomarqua@gmail.com)


=cut

# Copyright symbol gets munged by pod2man(1), so we'll fall back on using '(C)'
# Copyright © 2013, 2016, 2017 Alan D. Salewski <salewski@att.net>

=pod 

=head1 COPYLEFT

Copyright (C) 2013, 2016, 2017 Alan D. Salewski <salewski@att.net>

License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

=cut


# Local Variables:
#     mode: sh
#     eval: (sh-set-shell "bash" t nil)
# End:
