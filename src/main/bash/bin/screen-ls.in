# @configure_input@
#
# Copyright (C) 2013, 2016, 2017, 2019 Alan D. Salewski <salewski@att.net>
#
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License along
#    with this program; if not, write to the Free Software Foundation, Inc.,
#    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#
#
# screen-ls: Pretty-prints the output from 'screen -ls' on stdout. Prints the
# session names (without the leading pid and '.'  char) from the output of the
# 'screen -ls' command. With the '-l' ('--long') option, will print the full
# output in a readable table. With the '-p' ('--show-pid') option, will
# include the pid and '.' char which are suppressed by default.
#
# Any options not recognized by 'screen-ls' will be passed through to
# 'screen'. You can explicitly stop 'screen-ls' options processing by using
# the '--' pseudo-option; all options after that will be passed through to
# 'screen'.
#
# See screen-ls(1) for the full story (or run the 'perldoc' program on this
# file).
#
# Exit status will be zero upon success, non-zero upon error (invalid
# arguments provided to this program, for example).

set -o pipefail

declare -r PROG='screen-ls'

declare -r COPYRIGHT_DATES='2013, 2016, 2017, 2019'

declare -r gl_maintainer_addr='@DFLT_MAINTAINER@'  # filtered in at build time

# This variable is replaced by the current screen-wrappers project version
# number at build time.
declare -r SCREEN_WRAPPERS_VERSION='@VERSION@'

# This variable is replaced at build time
declare -r gl_const_build_date='@BUILD_DATE@'
declare -r gl_const_release="${SCREEN_WRAPPERS_VERSION}  (built: ${gl_const_build_date})"


# GitHub issue #11: Unset GREP_OPTIONS to make grep(1) behavior predictable.
#
# This only has an effect if the grep program in use is GNU grep; other grep
# implementations did not recognize or alter their behavior based on the
# 'GREP_OPTIONS' variable. GNU grep prior to version 2.11 (~2014-11) would
# append values from this variable to the command line, which would make
# behavior of our invocations in the current program unpredictable. Versions
# of GNU grep 2.11 or newer no longer behave that way, but do emit a warning
# on stderr about the change in behavior.
#
# Unsetting GREP_OPTIONS here has the effect of making our grep invocations
# predictable (when older versions of GNU grep are in use) and also of
# suppressing the spurious warning:
#
#     grep: warning: GREP_OPTIONS is deprecated; please use an alias or script
#
# when newer versions of GNU grep are in use.
#
# See: https://github.com/salewski/screen-wrappers/issues/11
#
unset GREP_OPTIONS


declare -r PROG_SCREEN='@SCREEN@'  # GNU 'screen' command found at configure time

declare -r PROG_COLUMN='@COLUMN@'  # BSD 'column' command found at configure time

# mode flags
declare gl_be_verbose=false       # Boolean. See -v switch.

declare opt_show_long=false       # Dflt; override via the -l switch
declare opt_show_pid=false        # Dflt; override via the -p switch
declare opt_show_sorted=true      # Dflt; override via the -U switch

# This gets set from f_is_screen_4_dot_3_or_newer()
#
# FIXME: Create function to set this explicitly, and then use the value set as
#        a parameter to f_is_screen_4_dot_3_or_newer()
#
declare SCREEN_VERSION_STRING=

# Regex that matches strings that would be interpretted by bash as legitimate
# identifiers /for assignment/. From the "DEFINITIONS" section of bash(1):
#     ...
#        word   A sequence of characters considered as a single unit by the
#               shell. Also known as a token.
#
#        name   A word consisting only of alphanumeric characters and underscores,
#               and beginning with an alphabetic character or an underscore.  Also
#               referred to as an identifier.
#     ...
#
# Note that $0 and $_ are "Special Parameters" and consequently may only be
# referenced (assignment to special parameters is not allowed). We therefore
# take special care to /not/ accept '0' and '_' as a legit identifiers for
# assignment.
#
# "Positional Parameters" are denoted by one or more digits, other than the
# single digit '0'. While they may be set using the 'set' builtin command,
# they cannot be directly assigned to. We therefore take special care to /not/
# accept sequences of /only/ digits as legit identifiers for assignment.
#
# If the identifier begins with an underscore, then it must contain one or
# more other legit identifier characters, as well.
#
# If the identifier begins with an alphabetic character, then it can stand on
# its own, or be followed by one or more other legit identifier characters.
#
# Legit identifiers cannot begin with numeric values.
#
# See: f_legit_bash_identifier_p(...)
#
declare -r RE_LEGIT_BASH_IDENTIFIER='^([_][_[:alnum:]]{1,}|[[:alpha:]][_[:alnum:]]{0,})$'

declare -a F_CLEANUP_HOOK_NAMES=()

function f_add_cleanup_hook_name () {
    F_CLEANUP_HOOK_NAMES+=( $1 );
}


function f_cleanup () {

    if test ${#F_CLEANUP_HOOK_NAMES[@]} -eq 0; then
        # No cleanup hooks, so nothing to do
        return
    fi

    local cleanup_hook
    local idx

    let idx=${#F_CLEANUP_HOOK_NAMES[@]}-1

    # Note that we're running the cleanup hooks in opposite order from which
    # they were installed.
    #
    while test $idx -ge 0; do

        cleanup_hook=${F_CLEANUP_HOOK_NAMES[$idx]}

        if $gl_be_verbose; then
            printf "${PROG} (info): running cleanup hook: [%s]\n" "${cleanup_hook}" 1>&2
        fi

        test -n "$cleanup_hook" && eval "$cleanup_hook"

        let idx=$idx-1
    done
}

function f_cleanup_and_die () {
    f_cleanup
    exit 1
}

trap 'printf "$PROG (warn): HUP signal caught; bailing out\n"  1>&2; f_cleanup_and_die' HUP
trap 'printf "$PROG (warn): INT signal caught; bailing out\n"  1>&2; f_cleanup_and_die' INT
trap 'printf "$PROG (warn): QUIT signal caught; bailing out\n" 1>&2; f_cleanup_and_die' QUIT
trap 'printf "$PROG (warn): TERM signal caught; bailing out\n" 1>&2; f_cleanup_and_die' TERM

trap 'f_cleanup' EXIT


# This is a list of command line arguments that we'll "pass through" to the
# screen(1) program. Note that if a screen-ls option name clashes with a
# screen(1) opt, the user can specify '--' in front of the options intended
# for screen-ls(1) and we'll pass those through (because we stop processing
# option once we encounter '--')
declare -a ARGS_FOR_SCREEN=()


f_print_help () {

    cat <<EOF
usage: $PROG [OPTION...]
Pretty-prints the output from 'screen -ls' on stdout.

  -h, --help      Print this help message on stdout
  -l, --long      Use long listing format
  -p, --show-pid  Shows the '<pid>.' prefix in screen(1) session names
  -U, --unsorted  Do not sort; list screen sessions in order output by screen(1)
  -V, --version   Print the version of the program on stdout
  -v, --verbose   Tell what is being done. Two or more -v options turns on tracing (set -x)

      --          Signals the end of options and disables further options processing. All
                    remaining arguments will be passed through to screen(1)

Any provided options that are not recognized by $PROG (that is, any
options that are not in the above list) will be passed through to screen(1).

Report bugs to ${gl_maintainer_addr}
EOF
}

f_print_version () {
    cat <<EOF
${PROG} ${gl_const_release}

Copyright (C) ${COPYRIGHT_DATES} Alan D. Salewski <salewski@att.net>
License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written by Alan D. Salewski.
EOF
}


# Predicate that indicates whether or not the value provided by V_NAME could
# be used as a bash identifier.
#
# Note that this predicate checks only the structure of the value provided in
# V_NAME; a successful return status DOES NOT assert that a variable with the
# name specified by the value in V_NAME is actually known to exist.
#
# Note, too, that the checks performed are according to the bash(1)
# documentation for a 'word' and a 'name'. When creating actual variables or
# functions, bash does allow for the use of values outside of what is
# considered legit here (e.g., functions with hyphens, periods, and/or colons
# in their names). And parent processes that invoke bash can jam any old weird
# thing into the environment of a bash subprocess).
#
# @param V_NAME (required) - The name to test
#
# @return 0 for TRUE, 1 for FALSE (so works with normal shell condition
#         constructs that expect these values).
#
function f_legit_bash_identifier_p () {

    local __t_required_count=1
    if test $# -ne ${__t_required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
               $# ${__t_required_count} 1>&2
        exit 1
    fi
    unset __t_required_count

    local __t_variable_name  # name to test
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_variable_name' 1>&2
        exit 1
    fi

    __t_variable_name=$1

    # XXX: redundant with the next test; consider deleting...
    if [[ ${__t_variable_name} =~ ^[[:space:]]*$ ]]; then
        : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): value provided for V_NAME argument is blank, so is not a legit bash identifier
        return 1  # false
    fi

    if [[ ${__t_variable_name} =~ ${RE_LEGIT_BASH_IDENTIFIER} ]]; then :; else
        : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): value provided for V_NAME argument is not a legit bash identifier
        return 1  # false
    fi

    return 0  # true
}


# Helper function for 'f_*legit_global_assoc_ary_bash_identifer_p'
# predicates. All invocations indicate whether or not the variable named by
# V_NAME is a globally defined associative array (e.g. created via 'declare -A ...').
#
# Optionally (based on the value provided for the required ATTRS param)
# performs additional checks on the attributes of the array (such as whether
# or not it was declared as readonly).
#
# @param V_NAME (required) - The name to test
#
# @param ATTRS  (required) - Valid values include 'READ-ONLY', 'READ-WRITE', and 'ANY'.
#
# @return 0 ("true") or 1 ("false") to indicate whether or not the requested
#         criteria were satisfied.
#
#         If any processing errors are encountered, does not return;it instead
#         exits with an error code.
#
# See also:
#     f_legit_bash_identifier_p( V_NAME)
#
#     f_writable_legit_global_assoc_ary_bash_identifier( V_NAME )
#     f_readonly_legit_global_assoc_ary_bash_identifier( V_NAME )
#
function __f_legit_global_assoc_ary_bash_identifier_helper_or_die () {

    # XXX: Maybe make ATTRS an optional argument, and use 'ANY' as the default.
    local __t_required_count=2
    if test $# -ne ${__t_required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
               $# ${__t_required_count} 1>&2
        exit 1
    fi
    unset __t_required_count

    local __t_variable_name  # name to test
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_variable_name' 1>&2
        exit 1
    fi

    __t_variable_name=$1

    local -a __t_all_legit_wanted_attrs=( 'READ-ONLY' 'READ-WRITE' 'ANY' )
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_all_legit_wanted_attrs' 1>&2
        exit 1
    fi
    local -r __t_all_legit_wanted_attrs
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable \"%s\" as read-only; bailing out\n" '__t_all_legit_wanted_attrs' 1>&2
        exit 1
    fi

    local __t_wanted_attr
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_wanted_attr' 1>&2
        exit 1
    fi

    __t_wanted_attr=$2
    local __t_wanted_attr_is_legit=false
    for __t_one_legit_attr in "${__t_all_legit_wanted_attrs[@]}"; do

        if test "${__t_one_legit_attr}" = "${__t_wanted_attr}"; then
            __t_wanted_attr_is_legit=true
            break
        fi
    done

    if ${__t_wanted_attr_is_legit}; then :; else
        printf "${PROG} (BUG): ${FUNCNAME}(): unrecognized value (\"%s\") provided for required ATTRS param; bailing out\n" \
               "${__t_wanted_attr}" 1>&2
        exit 1
    fi

    # Invocation is good; now get down to business...

    if f_legit_bash_identifier_p "${__t_variable_name}"; then :; else
        : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): value provided for V_NAME argument is not a legit bash identifier, so is not a legit global associative array identifier
        return 1  # false
    fi

    local __t_variable_attrs
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_variable_attrs' 1>&2
        exit 1
    fi

    # If the named variable is a pre-declared associative array, then the
    # output of 'declare -p' on it will look something like:
    #
    #     declare -A FOO=()
    #
    # where the 'A' in the second field tells us that the name represents an
    # associative array. In this example, if FOO were not an associative
    # array, we would expect the 'declare -p' output to look something like
    # this:
    #
    #     declare -- FOO
    #
    # However, if the variable named does not even exist, then our 'declare
    # -p...' invocation would emit on stderr something like:
    #
    #     ...declare: SOME_VARIABLE_NAME: not found
    #
    # which is why we redirect stderr to /dev/null.
    #
    __t_variable_attrs=$(declare -g -p "${__t_variable_name}" 2>/dev/null | awk '{ print $2 }')

    # XXX: Checks assume pipefail is enabled, and that 'declare' exit status
    #      will be non-zero for a non-existant variable.
    if test $? -eq 0 \
    && test -z "${__t_variable_attrs}"; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to obtain the attributes of the variable named \"%s\"; bailing out\n" \
               "${__t_variable_attrs}" 1>&2
        exit 1
    fi
    case ${__t_variable_attrs} in
        *A* )
            : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): ${__t_variable_name} has been confirmed to be the name of a global associative array
            ;;

        * )
            : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): ${__t_variable_name} is not a predefined global associative array
            : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): predicate value: 1 \( "false" \)
            return 1  # false
            ;;
    esac

    case ${__t_wanted_attr} in
        'ANY' )
            # No additional attributes to check.
            : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): predicate value: 0 \( "true" \)
            return 0;  # true
            ;;

        'READ-ONLY')
            case ${__t_variable_attrs} in
                *r* )
                    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): ${__t_variable_name} has been confirmed to have the readonly attribute set
                    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): predicate value: 0 \( "true" \)
                    return 0;  # true
                    ;;

                * )
                    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): ${__t_variable_name} does not have the readonly attribute set
                    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): predicate value: 1 \( "false" \)
                    return 1  # false
                    ;;
            esac
            ;;

        'READ-WRITE')
            case ${__t_variable_attrs} in
                *r* )
                    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): ${__t_variable_name} has been confirmed to have the readonly attribute set, but caller wants read-write
                    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): predicate value: 1 \( "false" \)
                    return 1;  # false
                    ;;

                * )
                    # If it's not readonly then it is read/write...
                    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): ${__t_variable_name} is read/write \( because it does not have the readonly attribute set \)
                    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): predicate value: 0 \( "true" \)
                    return 0  # true
                    ;;
            esac
            ;;

        * )
            # Should never happen...
            printf "${PROG} (BUG): ${FUNCNAME}(): unrecognized value for %s: \"%s\"; bailing out\n" \
                   '__t_wanted_attr' \
                   "${__t_wanted_attr}" 1>&2
            exit 1
            ;;
    esac

    printf "${PROG} (BUG): ${FUNCNAME}()[line: ${LINENO}]: should not fall through this line; bailing out\n" 1>&2
    exit 1
}


# Predicate that indicates whether or not the variable named by V_NAME is a
# globally defined associative array (e.g. created via 'declare -A ...').
#
# @param V_NAME (required) - The name to test
#
# See also:
#     f_legit_bash_identifier_p( V_NAME)
#
#     f_legit_global_assoc_ary_bash_identifier_p( V_NAME )
#
#     f_writable_legit_global_assoc_ary_bash_identifier_p( V_NAME )
#     f_readonly_legit_global_assoc_ary_bash_identifier_p( V_NAME )
#
function f_legit_global_assoc_ary_bash_identifier_p () {

    local __t_required_count=1
    if test $# -ne ${__t_required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
               $# ${__t_required_count} 1>&2
        exit 1
    fi
    unset __t_required_count

    if __f_legit_global_assoc_ary_bash_identifier_helper_or_die "$1" 'ANY'; then
        : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): predicate value: 0 \( "true" \)
        return 0;  # true
    fi

    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): predicate value: 1 \( "false" \)
    return 1;  # false
}

# Predicate that indicates whether or not the variable named by V_NAME is a
# globally defined associative array (e.g. created via 'declare -A ...') that
# is read-only (that is, that has the readonly attribute set).
#
# @param V_NAME (required) - The name to test
#
# See also:
#     f_legit_bash_identifier_p( V_NAME)
#
#     f_legit_global_assoc_ary_bash_identifier_p( V_NAME )
#
#     f_writable_legit_global_assoc_ary_bash_identifier_p( V_NAME )
#
function f_readonly_legit_global_assoc_ary_bash_identifier_p () {

    local __t_required_count=1
    if test $# -ne ${__t_required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
               $# ${__t_required_count} 1>&2
        exit 1
    fi
    unset __t_required_count

    if __f_legit_global_assoc_ary_bash_identifier_helper_or_die "$1" 'READ-ONLY'; then
        : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): predicate value: 0 \( "true" \)
        return 0;  # true
    fi

    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): predicate value: 1 \( "false" \)
    return 1;  # false
}


# Predicate that indicates whether or not the variable named by V_NAME is a
# globally defined associative array (e.g. created via 'declare -A ...') that
# is writable (that is, that DOES NOT have the readonly attribute set).
#
# @param V_NAME (required) - The name to test
#
# See also:
#     f_legit_bash_identifier_p( V_NAME)
#
#     f_legit_global_assoc_ary_bash_identifier_p( V_NAME )
#
#     f_writable_legit_global_assoc_ary_bash_identifier_p( V_NAME )
#
function f_writable_legit_global_assoc_ary_bash_identifier_p () {

    local __t_required_count=1
    if test $# -ne ${__t_required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
               $# ${__t_required_count} 1>&2
        exit 1
    fi
    unset __t_required_count

    if __f_legit_global_assoc_ary_bash_identifier_helper_or_die "$1" 'READ-WRITE'; then
        : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): predicate value: 0 \( "true" \)
        return 0;  # true
    fi

    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): predicate value: 1 \( "false" \)
    return 1;  # false
}


# Helper function to store a given value (or nothing, if no value is provided)
# to the variable named by V_NAME in the current shell.
#
# The idea is that callers invoke some function f_foo_func with the name of a
# variable provided as a parameter, and such functions internally invoke this
# one with both that name (V_NAME) and a value (VALUE) as a parameters. This
# allows callers of other functions to obtain output values from those
# functions without spawning a subshell. It allows one to replace variations
# of this:
#
#     somevalue=$(somefunc arg1 arg2)
#
# with this:
#
#     somefunc somevalue arg1 arg2
#     ...
#     # do something with $somevalue
#
# Note that 'somevalue' (passed as the first argument to somefunc() in the
# second example) is a string literal that names the variable that is to be
# set in the current shell.
#
# This approach also allows foo_or_die(...) functions to behave as you would
# want them to:
#
#    # wrong (exit status still needs to be checked and acted upon by the caller):
#    somevalue=$(somefunc_or_die arg1 arg2)
#    if test $? -ne 0; then ...; fi
#
#    # right (less verbose code needed at calling location):
#    somefunc_or_die somevalue arg1 arg2
#
# @param V_NAME (required) - The name of the variable to set.
#
# @param VALUE  (optional) - The value to give to the variable named by V_NAME
#
# See also:
#     f_set_named_index_array_or_die( V_NAME, ... )
#     f_set_named_assoc_array_or_die( V_NAME, ... )
#
f_set_named_scalar_or_die () {

    local __minimal_count=1
    local __maximal_count=2
    if test $# -lt ${__minimal_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; (at least) %d required; bailing out\n" \
            $# ${__minimal_count} 1>&2
        exit 1
    fi
    if test $# -gt ${__maximal_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; (at most) %d expected; bailing out\n" \
            $# ${__maximal_count} 1>&2
        exit 1
    fi

    local __variable_name
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__variable_name' 1>&2
        exit 1
    fi
    __variable_name=$1

    unset -v "${__variable_name}"
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() value provided for variable name (\"%s\") is not a valid identifier; bailing out\n" \
               "${__variable_name}" 1>&2
        exit 1
    fi

    # Using an array here allows us to use the magic "${__variable_value[@]}"
    # syntax below, which will do what we want (expand to a quoted something
    # if non-empty, else expand to nothing) regardless of whether or not a
    # variable value was provided by the caller.
    #
    local -a __variable_value
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__variable_value' 1>&2
        exit 1
    fi

    if test $# -gt 1; then
        __variable_value+=( "$2" )
    fi

    printf -v "${__variable_name}" '%s' "${__variable_value[@]}"

    if test $? -ne 0; then
        printf "${PROG} (error): was unable to set the value of variable named \"%s\"; bailing out\n" "${__variable_name}" 1>&2
        exit 1
    fi

    return 0  # success
}


# Similar to f_set_named_scalar_or_die(), but for setting associative arrays.
#
# CAREFUL: Uses 'eval' to set the key/value pairs on V_NAME_ARY_ASSOC; be sure
#          to sanitize your arguments!
#
#     somevalue=$(somefunc key1 arg1 key2 arg2 ...)
#
# @param V_NAME_ARY_ASSOC (required) - The name of the associative array
#                         variable to set. Must name an existing global assoc
#                         array (must have already been created via 'declare -A ...'
#                         by the caller).
#
# @param KEY_VAL_PAIRS  (optional) - Zero or more alternating keys/value pairs.
#
f_set_named_assoc_array_or_die () {

    local __minimal_count=1
    # no maximal count; we will accept an arbitrary number of key/value pairs (starting with none at all)

    if test $# -lt ${__minimal_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; (at least) %d required; bailing out\n" \
            $# ${__minimal_count} 1>&2
        exit 1
    fi

    local __t_variable_name  # name of an output variable (an associative array)
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_variable_name' 1>&2
        exit 1
    fi

    __t_variable_name=$1
    shift

    # FIXME: For symmetry with f_set_named_scalar_or_die(), maybe create the
    #        global assoc array (declare -g -A ...) if it is found to have not
    #        been predeclared.
    #
    if f_writable_legit_global_assoc_ary_bash_identifier_p "${__t_variable_name}"; then :; else
        printf "${PROG} (BUG): ${FUNCNAME}(): value provided for V_NAME_ARY_ASSOC argument (\"%s\") is not a legit, writable global associative array identifier; bailing out\n" \
               "${__t_variable_name}" 1>&2
        exit 1
    fi

    local __t_key
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_key' 1>&2
        exit 1
    fi

    # Using an array here allows us to use the magic "${__t_val[@]}" syntax
    # below, which will do what we want (expand to a quoted something if
    # non-empty, else expand to nothing) regardless of whether or not a
    # variable value was provided by the caller.
    #
    local -a __t_val
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_val' 1>&2
        exit 1
    fi

    while test $# -gt 0; do
        __t_key=$1
        shift

        if test $# -gt 0; then
            __t_val+=( "$1" )
            shift
        fi

        # XXX: Using eval; make sure you've sanitized your params!
        if test ${#__t_val[@]} -eq 0; then
            eval "${__t_variable_name}[${__t_key}]="
        else
            eval "${__t_variable_name}[${__t_key}]=\"${__t_val[@]}\""
        fi

        if test $? -ne 0; then
            printf "${PROG} (error): was unable to set the key '%s' of assoc array variable named \"%s\"; bailing out\n" \
                   "${__t_key}" \
                   "${__t_variable_name}" 1>&2
            exit 1
        fi

        __t_val=()   # reset
    done

    return 0  # success
}


# This is not currently needed in this prog (but see f_set_named_scalar and f_set_named_assoc_array_or_die above):
# f_set_named_index_array_or_die( V_NAME, ... )



# Uses the provided FPATH_PROG_SCREEN (screen(1)) program to obtain the output
# produced when invoked with its '--version' parameter, parsed here to obtain
# just the version number field. The value thus obtained is then used to set
# the variable named by the V_NAME parameter.
#
# If any errors are encountered (e.g., 'screen --version' cannot be invoked
# for some reason), then exits with an error code.
#
# @param V_NAME (required) - The name of the variable to set (output variable).
#
# @param PROG_SCREEN (required) - The screen(1) executable to use (this allows
#                                 us to avoid over-reliance on global variables)
#
f_obtain_screen_version_string_or_die () {

    local __required_count=2
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
               $# ${__required_count} 1>&2
        exit 1
    fi


    local __t_variable_name        # name of an output variable
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_variable_name' 1>&2
        exit 1
    fi

    __t_variable_name=$1

    if [[ ${__t_variable_name} =~ ^[[:space:]]*$ ]]; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with blank value for required V_NAME param; bailing out\n" 1>&2
        exit 1
    fi

    # FIXME: This is gross; use external function(s) to check variable attributes
    unset -v "${__t_variable_name}"
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() value provided for variable name (\"%s\") is not a valid identifier; bailing out\n" \
               "${__t_variable_name}" 1>&2
        exit 1
    fi


    local __t_fpath_prog_screen
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_fpath_prog_screen' 1>&2
        exit 1
    fi

    __t_fpath_prog_screen=$2

    if [[ ${__t_fpath_prog_screen} =~ ^[[:space:]]*$ ]]; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with blank value for required FPATH_PROG_SCREEN param; bailing out\n" 1>&2
        exit 1
    fi


    local __t_screen_version_number_snippet

    # Examples of how GNU screen advertizes its version:
    #
    #     Screen version 4.00.03jw4 (FAU) 2-May-06
    #     Screen version 4.03.01 (GNU) 28-Jun-15
    #     Screen version 4.05.00 (GNU) 10-Dec-16

    # XXX: This could fail on some mutant compilation of GNU screen
    #
    __t_screen_version_number_snippet=$( set -o pipefail;

                                         # This pipeline will print the value we want to capture.
                                         #
                                         # Note that we start parsing at the first digit...
                                         #
                                         "${__t_fpath_prog_screen}" --version \
                                           | head -n 1 \
                                           | sed -n -e 's#^[^[:digit:].]\{1,\}\([[:alnum:]]\{1,\}[.][[:alnum:]]\{1,\}[.][[:alnum:]]\{1,\}\).*#\1#p';

                                         # Some (all?) versions of screen will exit with status 1 when invoked with
                                         # just the '--version' option, so we allow for that here...
                                         #
                                         declare -a pstat=( ${PIPESTATUS[@]} )
                                         if test ${#pstat[@]} -eq 3 \
                                         \
                                         && test ${pstat[0]} -ge 0  \
                                         && test ${pstat[0]} -le 1  \
                                         \
                                         && test ${pstat[1]} -eq 0  \
                                         && test ${pstat[2]} -eq 0; then
                                             # Condense all that down into a single "success" code
                                             exit 0
                                         fi
                                         exit 1
                                       )
    if test $? -ne 0 \
    || test -z "${__t_screen_version_number_snippet}"; then
        printf "${PROG} (error): was unable to obtain output from 'screen --version'; bailing out\n" 1>&2
        exit 1
    fi

    f_set_named_scalar_or_die "${__t_variable_name}" "${__t_screen_version_number_snippet}"

    return 0;  # success
}


# Parses the output of 'screen --version' and stores the constituent parts in
# raw form in the associative array named by the V_NAME_ARY_ASSOC_RAW param. A
# "digits only" form is stored in the associative array named by the
# V_NAME_ARY_ASSOC_NUM param (see below for details). The keys of both arrays
# will be 'MAJOR', 'MINOR', and 'REVISION'.
#
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# CAREFUL: Note that 'eval' is employed to set the associative arrays named by
#          V_NAME_ARY_ASSOC_RAW and V_NAME_ARY_ASSOC_NUM (because it is not
#          (yet?) possible to access assign to arrays using namerefs).
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#
# @param V_NAME_ARY_ASSOC_RAW (required) - The name of the associative array
#        variable to set with the constituent parts of the screen(1) version
#        number in their raw form (values may contain leading zeros and
#        non-digit characters). The key names will be 'MAJOR', 'MINOR', and
#        'REVISION'.
#
# @param V_NAME_ARY_ASSOC_NUM (required) - The name of the associative array
#        variable to set with the constituent parts of the screen(1) version
#        number in a sanitized but lossy form (leading zeros will have been
#        stripped, and non-digit characters will have been dropped). The key
#        names will be 'MAJOR', 'MINOR', and 'REVISION'.
#
# @param SCREEN_VERSION_STRING (required) - The screen(1) version number
#        string to parse (such as obtained by a call to
#        f_obtain_screen_version_string_or_die(...)).
#
f_parse_screen_program_version_or_die () {

    local __required_count=3
    if test $# -ne ${__required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; exactly %d required; bailing out\n" \
               $# ${__required_count} 1>&2
        exit 1
    fi


    local __t_variable_name_raw  # name of an output variable (an associative array)
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_variable_name_raw' 1>&2
        exit 1
    fi
    __t_variable_name_raw=$1

    if f_writable_legit_global_assoc_ary_bash_identifier_p "${__t_variable_name_raw}"; then :; else
        printf "${PROG} (BUG): ${FUNCNAME}(): value provided for V_NAME_ARY_ASSOC_RAW argument (\"%s\") is not a legit, writable global associative array identifier; bailing out\n" \
               "${__t_variable_name_raw}" 1>&2
        exit 1
    fi


    local __t_variable_name_num  # name of an output variable (an associative array)
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_variable_name_num' 1>&2
        exit 1
    fi
    __t_variable_name_num=$2

    if f_writable_legit_global_assoc_ary_bash_identifier_p "${__t_variable_name_num}"; then :; else
        printf "${PROG} (BUG): ${FUNCNAME}(): value provided for V_NAME_ARY_ASSOC_NUM argument (\"%s\") is not a legit, writable global associative array identifier; bailing out\n" \
               "${__t_variable_name_num}" 1>&2
        exit 1
    fi


    local __t_screen_version_string
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_screen_version_string' 1>&2
        exit 1
    fi
    __t_screen_version_string=$3

    if test -z "${__t_screen_version_string}"; then
        printf "${PROG} (BUG): ${FUNCNAME}() value provided for SCREEN_VERSION_STRING param may not be the empty string; bailing out\n" 1>&2
        exit 1
    fi
    if [[ ${__t_screen_version_string} =~ ^[[:space:]]*$ ]]; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with blank value for required SCREEN_VERSION_STRING param; bailing out\n" 1>&2
        exit 1
    fi


    local __t_local_major_raw ; local __t_local_major_num
    local __t_local_minor_raw ; local __t_local_minor_num
    local __t_local_revis_raw ; local __t_local_revis_num

    # HINT: For examples of screen(1) version strings seen in the wild, see
    #       the comments in f_obtain_screen_version_string_or_die().

    # Alphanumerics (typically just digits) through the first dot are the major version number
    #
    __t_local_major_raw=$(echo "${__t_screen_version_string}" | sed -n -e 's#^\([[:alnum:]]\{1,\}\)[.].*#\1#p')

    if test -z "${__t_local_major_raw}"; then
        printf "${PROG} (warning): was unable to determine the major version number of screen\n" 1>&2
        return 1  # false
    fi

    # Alphanumerics (typically just digits) between the first and second dot are the minor version number
    #
    __t_local_minor_raw=$(echo "${__t_screen_version_string}" | sed -n -e 's#^[[:alnum:]]\{1,\}[.]\([[:alnum:]]\{1,\}\)[.].*#\1#p')

    if test -z "${__t_local_minor_raw}"; then
        printf "${PROG} (warning): was unable to determine the minor version number of screen\n" 1>&2
        return 1  # false
    fi

    # Alphanumerics (often just digits, but non-digits have been seen in the wild) after the second dot are the revision number
    #
    __t_local_revis_raw=$(echo "${__t_screen_version_string}" | sed -n -e 's#^[[:alnum:]]\{1,\}[.][[:alnum:]]\{1,\}[.]\([[:alnum:]]\{1,\}\).*#\1#p')

    if test -z "${__t_local_revis_raw}"; then
        printf "${PROG} (warning): was unable to determine the revision number of screen\n" 1>&2
        return 1  # false
    fi

    # The MAJOR.MINOR.REVISION numbers reported by 'screen --version'
    # typically contain leading zeros which would cause the decimal numbers to
    # be interpretted as octal numbers, and may contain non-digit characters
    # that we are not interested in for purposes of numeric comparison.
    #
    # We'll take all leading digits to be the numeric portion of the version
    # number component. This allows for treating values such as:
    #
    #     4.00.03jw4
    #
    # as major: 4, minor: 0, and revision: 4 (it ignores the 'jw4' portion in
    # the revision). Once we have the numeric portion isolated, we then
    # effectively slice-off the leading zeros by telling the shell that we
    # want the base 10 values.
    # 
    __t_local_major_num=$((10#${__t_local_major_raw/%[^[:digit:]]*/}))
    __t_local_minor_num=$((10#${__t_local_minor_raw/%[^[:digit:]]*/}))
    __t_local_revis_num=$((10#${__t_local_revis_raw/%[^[:digit:]]*/}))

    f_set_named_assoc_array_or_die "${__t_variable_name_raw}" \
                                   'MAJOR'    ${__t_local_major_raw} \
                                   'MINOR'    ${__t_local_minor_raw} \
                                   'REVISION' ${__t_local_revis_raw}

    f_set_named_assoc_array_or_die "${__t_variable_name_num}" \
                                   'MAJOR'    ${__t_local_major_num} \
                                   'MINOR'    ${__t_local_minor_num} \
                                   'REVISION' ${__t_local_revis_num}

    return 0;  # success
}


# Checks the 'MAJOR' and 'MINOR' keys of the associative array named in
# SCREEN_VERSION_ASSOC_ARY_NAME, and returns success ("true") or failure
# ("false") to indicates whether or not the GNU screen(1) program version
# being used is 4.3.0 or newer.
#
# Exits with an error status upon any processing error.
#
# @param SCREEN_VERSION_ASSOC_ARY_NAME (required) - The name of a global
#        associative array variable representing the screen(1) version number
#        as numerals only (e.g., as produced for te V_NAME_ARY_ASSOC_NUM param
#        of a call to f_parse_screen_program_version_or_die(...). The assoc
#        array needs to be declared by the caller and accessible here by name
#        -- that's just due to the fact that bash cannot (yet?) pass assoc
#        array variables by reference to functions; we use a nameref, instead,
#        which is close enough for our needs here (since we are not assigning
#        to it).
#
f_is_screen_4_dot_3_or_newer () {

    local __t_required_count=1
    local __t_minimal_count=1
    local __t_maximal_count=1

    if test $# -lt ${__t_required_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; (at least) %d required; bailing out\n" \
            $# ${__t_minimal_count} 1>&2
        exit 1
    fi

    if test $# -gt ${__t_maximal_count}; then
        printf "${PROG} (BUG): ${FUNCNAME}() invoked with %d args; (at most) %d expected; bailing out\n" \
            $# ${__t_maximal_count} 1>&2
        exit 1
    fi

    local __t_screen_version_assoc_ary_name
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to declare local variable named \"%s\"; bailing out\n" '__t_screen_version_assoc_ary_name' 1>&2
        exit 1
    fi
    __t_screen_version_assoc_ary_name=$1

    if f_legit_global_assoc_ary_bash_identifier_p "${__t_screen_version_assoc_ary_name}"; then :; else
        printf "${PROG} (BUG): ${FUNCNAME}(): value provided for SCREEN_VERSION_ASSOC_ARY_NAME argument (\"%s\") is not a legit global associative array identifier; bailing out\n" \
               "${__t_screen_version_assoc_ary_name}" 1>&2
        exit 1
    fi

    local -n __t_screen_version_assoc_ary_name
    if test $? -ne 0; then
        printf "${PROG} (BUG): ${FUNCNAME}() was unable to give local variable named \"%s\" the nameref attribute; bailing out\n" '__t_screen_version_assoc_ary_name' 1>&2
        exit 1
    fi


    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): count of members of SCREEN_VERSION_ASSOC_ARY_NAME:     ${#__t_screen_version_assoc_ary_name[@]}

    if test 0 -eq ${#__t_screen_version_assoc_ary_name[@]}; then
        printf "${PROG} (BUG): ${FUNCNAME}() value provided for SCREEN_VERSION_ASSOC_ARY_NAME param may not be the name of an empty array; bailing out\n" 1>&2
        exit 1
    fi

    # Examples of how GNU screen advertizes its version:
    #
    #     Screen version 4.00.03jw4 (FAU) 2-May-06
    #     Screen version 4.03.01 (GNU) 28-Jun-15
    #     Screen version 4.05.00 (GNU) 10-Dec-16

    local __t_local_major
    local __t_local_minor

    __t_local_major=${__t_screen_version_assoc_ary_name['MAJOR']}
    if test -z "${__t_local_major}"; then
        printf "${PROG} (warning): was unable to determine the major version number of screen\n" 1>&2

        : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): non-die-worthy error encountered. Returning failure \(1\) for false.
        return 1  # XXX: error, but not really die-worthy?
    fi

    __t_local_minor=${__t_screen_version_assoc_ary_name['MINOR']}
    if test -z "${__t_local_minor}"; then
        printf "${PROG} (warning): was unable to determine the minor version number of screen\n" 1>&2

        : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): non-die-worthy error encountered. Returning failure \(1\) for false.
        return 1  # XXX: error, but not really die-worthy?
    fi


    # Note that there's a third 'revision' component to the advertized GNU
    # screen version number that we're ignoring here. We'll return a success
    # status for any version greater than or equal to 4.3.0.

    if test ${__t_local_major} -ge 4 \
    && test ${__t_local_minor} -ge 3; then
        : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): screen version is 4.3.0 or newer. Returning success \(0\) for true.
        return 0  # success (true); found version of screen is 4.3.0 or newer
    fi

    : $PROG \(trace: $LINENO\): ${FUNCNAME}\(\): screen version IS NOT 4.3.0 or newer. Returning success \(1\) for false.
    return 1  # success (false); found version of screen is older than 4.3.0
}


pos_last_plus_one=$(( $# + 1 ))

# Each value is one or zero, which indicates whether or not the option is
# expected to have an argument.
#
declare -A longopt_spec=(
    ['help']=0      # -h
    ['version']=0   # -V

    ['long']=0      # -l
    ['show-pid']=0  # -p
    ['unsorted']=0  # -U
    ['verbose']=0   # -v
)

# internal sanity check
for one_key in "${!longopt_spec[@]}"; do
    one_val=${longopt_spec[${one_key}]}
    if [[ $one_val =~ ^[01]$ ]]; then :; else
        printf "${PROG} (BUG) [line $LINENO]: value (%s) for longopt key '%s' must be either 0 or 1; bailing out\n" \
               "${one_val}" "${one_key}" 1>&2
        exit 1
    fi
done

if test $# -gt 0; then

    # Using getopts in "silent mode". Note that adding '-' to the optstring allows us to
    # process GNU-style long-form options; that option is specified to take an argument to
    # cause getopts to place whatever follows the second '-' character into OPTARG.
    #
    # Note that getopts will automatically stop processsing options upon encountering
    # '--', but we still need to deal with the pathological form --=BLAH (no option name,
    # just a value using the equals-sign syntax).
    #
    while getopts ':-:hlpUVv' opt
    do
        : $PROG \(trace: $LINENO\): opt is: $opt

        if test "${opt}" = '-'; then

            # Intercepting processing of long-form option. This conditional
            # block will set up the 'opt', 'OPTARG', and 'OPTIND' variables for
            # the code that follows, just as if getopts had the capability to
            # process long-form options.

            # OPTARG here is one of:
            #
            #     =BLAH    (which means user specified '--=BLAH')
            # or:
            #     foo
            # or:
            #     foo=FOOVAL

            if [[ ${OPTARG} =~ .*=.* ]]; then

                : $PROG \(trace: $LINENO\): OPTARG is name=value style

                # Keep everything up to the first '=' sign. Note that if the
                # option was specified as: --foo=FOOVAL, then $opt here will be
                # 'foo' (no hyphen chars).
                opt=${OPTARG/=*/}
                : $PROG \(trace: $LINENO\): opt is: $opt

                : $PROG \(trace: $LINENO\): a long option name must be at least two characters in length
                if test ${#opt} -le 1; then
                    printf "${PROG} (error): invalid long option '%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else

                    # Unrecognized option; we'll pass it through to screen(1). Note that
                    # we need to restore the leading '-' that getopts has sliced off.
                    #
                    ARGS_FOR_SCREEN[${#ARGS_FOR_SCREEN[@]}]="-${OPTARG}"
                    continue
                fi

                # Since we know the option was specified in --foo=BAR form, the
                # option was specified erroneously unless the option's long-form
                # spec indicates that it can accept an argument.
                #
                if test ${longopt_spec[${opt}]} -ne 1; then
                    printf "${PROG} (error): option '%s' does not take an argument; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                OPTARG=${OPTARG#*=}  # keep everything after the first '=' sign
                : $PROG \(trace: $LINENO\): OPTARG is: $OPTARG

            else
                : $PROG \(trace: $LINENO\): OPTARG is name-only style

                opt="$OPTARG"
                : $PROG \(trace: $LINENO\): opt is: $opt

                if test -z "${opt}"; then

                    # This should be a "can't happen" scenario; since bash's 'getopts'
                    # implementation should directly handle the magic '--' token, we
                    # should never fall through here.

                    printf "${PROG} (BUG) [line $LINENO]: received empty OPTARG, which means getopts did not handle the stand-alone '--' token; bailing out\n" 1>&2
                    exit 1
                fi

                : $PROG \(trace: $LINENO\): a non-empty long option name must be at least two characters in length
                if test ${#opt} -lt 2; then
                    printf "${PROG} (error): invalid long option '%s'; bailing out\n" "${opt}" 1>&2
                    f_print_help 1>&2
                    exit 1
                fi

                t_exists=false
                for one_key in "${!longopt_spec[@]}"; do
                    if test "${opt}" = "${one_key}"; then
                        t_exists=true
                        break
                    fi
                done

                if $t_exists; then :; else

                    # Unrecognized option; we'll pass it through to screen(1). Note that
                    # we need to restore the leading '-' that getopts has sliced off.
                    #
                    ARGS_FOR_SCREEN[${#ARGS_FOR_SCREEN[@]}]="-${OPTARG}"
                    continue
                fi

                # We know the option was specified in one of the following forms:
                #
                #     --foo
                # or:
                #     --foo FOOVAL
                #
                # The option's long-form spec will tell us whether or not an argument is
                # expected for the option.
                #
                if test ${longopt_spec[${opt}]} -eq 1; then

                    # If bumping OPTIND would put us more than one beyond the "last pos
                    # plus one", then there is no argument provided at position OPTIND for
                    # us to consume.
                    #
                    if (( $(( $OPTIND + 1 )) > pos_last_plus_one )); then

                        printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                        f_print_help 1>&2
                        exit 1
                    fi

                    OPTARG=${@:${OPTIND}:1}
                    (( ++OPTIND ))
                    : $PROG \(trace: $LINENO\): manually incremented OPTIND to: $OPTIND
                fi
            fi
        fi

        # Normal getopts style processing happens beneath here, with the slight
        # twist that 'opt' may contain a long-form option name.

        case $opt in

            'help' | 'h' )
                # print help message
                f_print_help
                exit 0
                ;;


            'long' | 'l' )
                opt_show_long=true
                ;;


            'show-pid' | 'p' )
                opt_show_pid=true
                ;;


            'unsorted' | 'U' )
                opt_show_sorted=false
                ;;


            'version' | 'V' )
                # print program version info
                f_print_version
                exit 0
                ;;


            'verbose' | 'v' )
                # Accumulating 'verbose' opt. A single -v opt simply turns $gl_be_verbose
                # on; two or more '-v' opts turns tracing on. Note that if you intend to
                # turn tracing on, you'll probably want your -v opts to be the first opts
                # on the command line (so they take effect earlier).
                #
                if $gl_be_verbose; then
                    # We've seen at least one -v opt before, so now we're turning tracing on
                    set -x
                else
                    # First -v opt we're seeing
                    gl_be_verbose=true
                fi
                ;;


            ':')  # getopts put : in opt
                  # Note that we need to restore the leading '-' that getopts
                  # has sliced off.
                  printf "${PROG} (error): missing argument for option -${OPTARG}\n" 1>&2
                  f_print_help 1>&2
                  exit 1
                  ;;

            '?')  # getopts put ? in opt
                  # Unrecognized option; we'll pass it through to screen(1). Note that we
                  # need to restore the leading '-' that getopts has sliced off.
                  ARGS_FOR_SCREEN[${#ARGS_FOR_SCREEN[@]}]="-${OPTARG}"
                  ;;

            * )   printf "${PROG} (BUG) [line $LINENO]: unhandled option case; opt: '$opt',  OPTARG: '$OPTARG'\n" 1>&2
                  ;;

        esac
    done
fi

# shift off all arguments already handled
let ii=1;  # shell OPTIND index starts at 1
while (( ii < ${OPTIND} )); do
    shift
    (( ++ii ))
    : $PROG \(trace: $LINENO\): ii is now: $ii
done

# Drain any remaining command line parameters not processed by getopts and add them to the
# list that we will pass through to screen(1):
while test $# -gt 0; do
    ARGS_FOR_SCREEN[${#ARGS_FOR_SCREEN[@]}]=$1
    shift
done


# Effectively a NOOP. Yes, arguably a UUoC, but useful because we're composing
# pipelines. If you know of a better way to do this, please speak up!
declare -r NOOP='cat -'  

chop_pid_command='sed -e ''s/^[[:space:]]*[[:digit:]]\{1,\}[.]//'

if $opt_show_pid; then
    chop_pid_command=$NOOP
fi


if $opt_show_long; then
    sed_or_column_command="${PROG_COLUMN}"' -t'
fi


# XXX: We're using any old 'sort' command here, which is good for
#      portability. However, maybe consider adding optional support (detected
#      at configure time) of a sort (such as GNU sort) that recognizes the
#      '--stable' option.
#
maybe_sort_command=$NOOP  # Represents '-U' (--unsorted) behavior
if $opt_show_sorted; then

    maybe_sort_command='sort -k1,1'  # sorting by screen session name when no pid prefix is present

    if $opt_show_pid; then

        # Sorting by screen session name when the pid prefix is present. Input
        # lines will start with values that look like:
        #
        #     779.screen-wrappers-dev
        #     14926.emacs-dev
        #
        # so we have to tell sort to "skip over" the pid portion.
        #
        maybe_sort_command='sort -t. -k2,2'  
    fi
fi

# The 'screen' program prior to version 4.0.3 (from 2015-06-12, advertized as
# '4.03.00' by 'screen --version') has a bug that causes the 'screen -ls'
# command to exit with status 1 upon success.
#
# For info on the upstream bug see:
#
#     http://savannah.gnu.org/bugs/?26750
#
# We want to work with either version, though, so we'll dynamically test the
# major.minor version numbers and adjust our behavior accordingly.
#
f_obtain_screen_version_string_or_die 'SCREEN_VERSION_STRING' "${PROG_SCREEN}"
#
# Parse the screen(1) program version, setting into two new assoc arrays
# (which we pre-declare here) with its constituent parts (one with the literal
# pieces, the other with just the numeric portions (which we consider "close
# enough" for our check here).
#
declare -A SCREEN_VERSION_ARRAY_RAW  # may contain non-numeric bits (e.g., from "4.00.03jw4")
declare -A SCREEN_VERSION_ARRAY_NUMERIC_ONLY

f_parse_screen_program_version_or_die 'SCREEN_VERSION_ARRAY_RAW'          \
                                      'SCREEN_VERSION_ARRAY_NUMERIC_ONLY' \
                                      "${SCREEN_VERSION_STRING}"

have_screen_4_dot_3_or_newer=false
if f_is_screen_4_dot_3_or_newer 'SCREEN_VERSION_ARRAY_NUMERIC_ONLY'; then
    have_screen_4_dot_3_or_newer=true
fi
#
# CAREFUL: The value of SCREEN_LS_ESTAT should match the value here only when
#          'screen -ls' is invoked and there is a matching socket (that, only
#          when there is one or more existing screen sessions).
#
#          When 'screen -ls' is invoked and there are no existing screen
#          sessions, the expected exit status is 1 for all versions of screen
#          the author has tested.
#
#          Note, too, that the '-q' option changes the meanings of the exit
#          status codes; see screen(1) and comments elsewhere in this file for
#          more info on that.
#
if $have_screen_4_dot_3_or_newer; then
    SCREEN_LS_ESTAT=0
else
    SCREEN_LS_ESTAT=1
fi

# From screen(1)  [screen version 4.00.03 (FAU) 23-Oct-06]:
# <quote>
#      -q   Suppress printing of error messages. In combination with "-ls" the
#           exit  value  is  as  follows: 9 indicates a directory without ses-
#           sions. 10 indicates a directory with running  but  not  attachable
#           sessions.  11 (or more) indicates 1 (or more) usable sessions.  In
#           combination with "-r" the exit value is as follows:  10  indicates
#           that  there  is  no session to resume. 12 (or more) indicates that
#           there are 2 (or more) sessions to resume and  you  should  specify
#           which one to choose.  In all other cases "-q" has no effect.
# </quote>
#
# [Note that the man page text for the option remains identical to the above
# as of screen version 4.05.00 (GNU) 10-Dec-16]
#
# That means that if we are careful, we can use the exit status directly to
# determine whether or not the user has any screen sessions:
#
#         9 means "no screen sessions"
#
#    10-125 means "at least one session" (bash(1) (section "EXIT STATUS")
#           documents special use of exit statuses greater than 125, so we
#           will only consider values greater than 10 but less than 125 as
#           having been produced directly by 'screen'. Note that we are only
#           concerned with the presence or non-presence of screen sessions;
#           this program does not care whether or not the sessions are usable
#           or resumable. If there are screen sessions present, we will report
#           on their presence.
#
declare -r -i SCREEN_Q_LS_ESTAT_NO_SCREEN_SESSIONS=9
# declare -r -i SCREEN_Q_LS_ESTAT_SCREEN_SESSIONS_PRESENT_MIN=10
declare -r -i SCREEN_Q_LS_ESTAT_SCREEN_SESSIONS_PRESENT_MAX=125
#
#
# The layout of the 'screen -q -ls' exit status codes allows us to consider a
# solid range of values as indicating command invocation "success":
declare -r -i SCREEN_Q_LS_ESTAT_SUCCESS_MIN=${SCREEN_Q_LS_ESTAT_NO_SCREEN_SESSIONS}
declare -r -i SCREEN_Q_LS_ESTAT_SUCCESS_MAX=${SCREEN_Q_LS_ESTAT_SCREEN_SESSIONS_PRESENT_MAX}


# GitHub issue #7 note: Different versions of 'screen' produce different
# output, so our regexen below try to be flexible enough to accommodate all of
# the variations known to the screen-wrappers author. If you encounter a
# different variation than those supported here, the result will likely be
# that screen-ls swallows all of the output from the 'screen -ls' command (so
# it will be obvious that there is a problem); please let the screen-wrappers
# author know!
#
# Examples of known output formats:
#
#             28189.screen-wrappers-hacking   (Attached)
#
#             28189.screen-wrappers-hacking   (06/22/2016 06:49:18 PM)        (Attached)
#

# Matches:
#             28189.screen-wrappers-hacking   (Attached)
#
# Note that we always need to have 3 capture groups, so we have an empty
# capture group in our expression here (where the date info is located in the
# output of newer versions of screen).
#
re_chunks_type_005='^[[:space:]]*([^[:space:]].*)[[:space:]]{1,}()([(][^)]{1,}[)])[[:space:]]*$'

# Matches:
#             28189.screen-wrappers-hacking   (06/22/2016 06:49:18 PM)        (Attached)
#
re_chunks_type_010='^[[:space:]]*([^[:space:]].*)[[:space:]]{1,}([(][^)]{1,}[)])[[:space:]]{1,}([(][^)]{1,}[)])[[:space:]]*$'

# This will be assigned to a regex captures the three fields of interest. The
# first time through one of the below two loops we will have to try various
# flavors of the regex, but once we've identified the type of 'screen -ls'
# output that we are dealing with we use the correct regex directly.
#
re_chunks=


# When running 'screen -ls', the first line of output on stdout (when there
# are no active screen sessions) will have this form:
#
#     No Sockets found in /run/screen/S-${USER}.
#
re_no_sockets_found_loose='No[[:space:]]{1,}Sockets[[:space:]]{1,}found'
re_no_sockets_found_tight='^'"${re_no_sockets_found_loose}"



# CAREFUL: Empirical testing (on screen version 4.00.03 (FAU) 23-Oct-06 and
#          screen version 4.05.00 (GNU) 10-Dec-16) reveals that the '-q'
#          option must come first for screen to exhibit the desired behavior
#          of exiting with meaningful exit statuses when combined with the
#          '-ls' option. In the author's testing, specifying the '-q' option
#          second causes screen to exit with status 1 and otherwise behave in
#          unexpected (and obviously incorrect) ways.
#
"${PROG_SCREEN}" -q -ls "${ARGS_FOR_SCREEN[@]}"
t_screen_q_ls_estat=$?

# Per the commentary above, we are expecting the 'screen -q -ls' exit status
# to be within a range of values (between 9 and 125) for any type of
# successful outcome.
if test ${t_screen_q_ls_estat} -lt ${SCREEN_Q_LS_ESTAT_SUCCESS_MIN} \
|| test ${t_screen_q_ls_estat} -gt ${SCREEN_Q_LS_ESTAT_SUCCESS_MAX}; then

    printf "${PROG} (error): was unable to execute 'screen -q -ls' (exit status was %d): bailing out\n" ${t_screen_q_ls_estat} 1>&2

    exit 1  # explicitly exit with status 1 (rather than ${SCREEN_Q_LS_ESTAT}
            # itself, as there is a non-zero chance that some future change in
            # screen behavior would cause it to exit with status zero here).
fi

: $PROG \(trace: $LINENO\): testing 'screen -q -ls' exit status \(${t_screen_q_ls_estat}\) against SCREEN_Q_LS_ESTAT_NO_SCREEN_SESSIONS \(${SCREEN_Q_LS_ESTAT_NO_SCREEN_SESSIONS}\)
if test ${t_screen_q_ls_estat} -eq ${SCREEN_Q_LS_ESTAT_NO_SCREEN_SESSIONS}; then

    : $PROG \(trace: $LINENO\): exit status of 'screen -q -ls' \(${t_screen_q_ls_estat}\) indicates that there are no existing screen sessions

    if $gl_be_verbose; then
        printf "${PROG} (info): no screen sessions exist (okay); exiting early with success status (no work left to do)\n" 1>&2
    fi

    exit 0
fi

unset t_screen_q_ls_estat


# If we are falling through here then we think there is one or more screen
# sessions to show the user. We will collect the output from 'screen -ls' and
# parse it to show the appropriate data to the end user.
#
# Note that there is an inherent race condition between our two invocations of
# 'screen' (our above 'screen -q -ls' invocation and our below 'screen -ls'
# invocation). We try to paper over any issues (e.g., all screen sessions
# having gone away) by parsing for the "no screen sessions available"
# scenario, even though we accounted for that in a more direct way above.


# The user would have to have a really pathological situation for the output
# from 'screen -ls' to be large enough that we could not easily hold it all in
# memory (if that describes you, though, then let the author know!).
#
DATA_SCREEN_LS_OUTPUT=$("${PROG_SCREEN}" -ls "${ARGS_FOR_SCREEN[@]}")
t_screen_ls_estat=$?
# if test ${t_screen_ls_estat} -ne ${SCREEN_LS_ESTAT}; then  # screen prior to 4.3.0 exits with status 1; later versions exit with status 0 (as expected). We'll work with either.
if test ${t_screen_ls_estat} -ne 0 \
&& test ${t_screen_ls_estat} -ne 1; then  # screen prior to 4.3.0 exits with status 1; later versions exit with status 0 (as expected). We'll work with either.

    printf "${PROG} (error): was unable to execute 'screen -ls': bailing out\n"  1>&2
    exit 1
fi


# XXX: It is conceivable that some future version of screen(1) might emit no
#      output for 'screen -ls' when the user has no screen sessions, but that
#      is not the case currently. This check will help us detect such behavior
#      changes and give us direct feedback about it (so the author can adjust
#      the behavior of this program accordingly). For the foreseeable future,
#      this should never happen...
if test -z "${DATA_SCREEN_LS_OUTPUT}"; then
    printf "${PROG} (BUG?): 'screen -ls' exited successfully, but produced no output (???): bailing out\n"  1>&2
    exit 1
fi

# We do the following check in two steps even though it could more efficiently
# be performed in one. The idea is that trace-level debugging will help us
# detect future behavior changes in which legit "No Sockets found" messages
# appear someplace other than anchored to the beginning of the first line of
# stdout.
#
if [[ "${DATA_SCREEN_LS_OUTPUT}" =~ $re_no_sockets_found_loose ]]; then

    # A "No Sockets found" type of string was found in the output of the
    # 'screen -ls' command, but we do not yet know whether or not it is
    # indicative of an unfortunate screen session name (see below comments) or
    # a legit scenario in which the user simply does not have any screen
    # sessions active.
    #
    # Even if the user does something pathological such as:
    #
    #     $ screen -S 'No Sockets found'
    #
    # the output of 'screen -ls' is expected to be such that the screen
    # session names are /not/ named on the first line of its output:
    #
    #     $ screen -ls
    #     There are screens on:
    #             19185.No Sockets found  (05/14/2017 12:35:33 PM)        (Attached)
    #
    # We should therefore be safe checking for the "No Sockets found" type of
    # message on the first line and using that to differentiate between the
    # two scenarios.
    #
    : $PROG \(trace: $LINENO\): checking for "No Sockets found" type of message on first line of 'screen -ls' output.

    t_first_line=$( builtin echo "${DATA_SCREEN_LS_OUTPUT}" | head -n 1)
    if test $? -ne 0; then
        printf "${PROG} (error): was unable to isolate first line of 'screen -ls' output: bailing out\n"  1>&2
        exit 1
    fi

    if [[ "${t_first_line}" =~ $re_no_sockets_found_tight ]]; then

        # Sanity check: Both old (4.3.0) and newer (4.5.0) versions of screen
        # exit with status 1 for 'screen -ls' when there are no screen
        # sessions available. If this changes, we want to know about it as it
        # might invalidate some of the decisions made by this program.
        if test ${t_screen_ls_estat} -ne 1; then
            printf "${PROG} (warning) 'screen -ls' indicates no screen sessions, but exited with status %d (expected status 1); continuing anyway\n" "${t_screen_ls_estat}" 1>&2
            # Keep going...
        fi

        : $PROG \(trace: $LINENO\): output text of 'screen -ls' \(${t_screen_ls_estat}\) indicates that there are no existing screen sessions

        if $gl_be_verbose; then
            printf "${PROG} (info): no screen sessions exist (okay); exiting early with success status (no work left to do)\n" 1>&2
        fi
        exit 0
    fi
    unset t_first_line
fi

# If we are falling through here, we expect that there is at least one active
# screen session. That means that ${t_screen_ls_estat} should match
# ${SCREEN_LS_ESTAT}, too.
#
: $PROG \(trace: $LINENO\): expecting there is at least one active screen session\; checking t_screen_last_estat \(${t_screen_last_estat}\) against SCREEN_LS_ESTAT \(${SCREEN_LS_ESTAT}\)
#
if test ${t_screen_ls_estat} -ne ${SCREEN_LS_ESTAT}; then  # screen prior to 4.3.0 exits with status 1; later versions exit with status 0 (as expected). We'll work with either.

    printf "${PROG} (error): detected existing screen sessions, but exit status of 'screen -ls' was %d (expected %d from installed screen version %s): bailing out\n" \
           "${t_screen_ls_estat}"     \
           "${SCREEN_LS_ESTAT}"       \
           "${SCREEN_VERSION_STRING}" \
           1>&2
    exit 1
fi
unset t_screen_ls_estat

if $opt_show_long; then

    builtin echo "${DATA_SCREEN_LS_OUTPUT}" \
    | tail -n +2 \
    | head -n -2 \
    | $chop_pid_command \
    | while read -r line; do

          : $PROG \(trace: $LINENO\): line: "$line"

          if test -z "${re_chunks}"; then

              # CAREFUL: Order of the regex tests is important
              #
              if   [[ "$line" =~ $re_chunks_type_010 ]]; then
                  re_chunks=$re_chunks_type_010

              elif [[ "$line" =~ $re_chunks_type_005 ]]; then
                  re_chunks=$re_chunks_type_005

              else
                  printf "${PROG} (error): unrecognized output from 'screen -ls':\n    \"%s\"\nBailing out\n" "$line" 1>&2
                  exit 1
              fi
          else
              if [[ "$line" =~ $re_chunks ]]; then :; else
                  printf "${PROG} (error): unrecognized output from 'screen -ls':\n    \"%s\"\nBailing out\n" "$line" 1>&2
                  exit 1
              fi
          fi

          t_session_name=${BASH_REMATCH[1]}   # may contain spaces
          t_session_date=${BASH_REMATCH[2]}   # will be empty if output is from an older version of screen
          t_session_state=${BASH_REMATCH[3]}  # '(Attached)', '(Detached)', ...

          # Recall that 0x1f is the ASCII "unit separator" character; used
          # here because it is exceedingly unlikely to appear in the output of
          # 'screen -ls'. That is the hope, at least...
          #
          # From ascii(7):
          #     Oct   Dec   Hex   Char
          #     ──────────────────────────────────────
          #     ...
          #     034   28    1C    FS  (file separator)
          #     035   29    1D    GS  (group separator)
          #     036   30    1E    RS  (record separator)
          #     037   31    1F    US  (unit separator)
          #     ...
          #
          # The rationale is that screen(1) session names may contain spaces
          # in them, so we need to doctor-up the input to column(1) to allow
          # it to definitively distinguish which values belong in which
          # column.
          #
          printf '%s%s%s%s%s%s\n' \
              "${t_session_name}"  $'\x1f' \
              "${t_session_date}"  $'\x1f' \
              "${t_session_state}" $'\x1f'
      done \
    | $maybe_sort_command \
    | "${PROG_COLUMN}" -s $'\x1f' -t

    # Note that we can't use bash's 'pipefail' option because 'screen -ls' (at
    # least as of the 4.01.00devel version shipped with Debian) exits with
    # non-zero status upon success. There's an open (as of 2013-07-08) issue
    # for this filed in the upstream issue tracker for this behavior:
    #
    #     http://savannah.gnu.org/bugs/?26750
    #
    # It's been open since 2009, though, so maybe isn't easy to fix...
    #
    # In any event, we'll need to check the exit status of each command in the
    # pipeline individually using the PIPESTATUS array.

    declare -a t_estat_arr=( ${PIPESTATUS[@]} )

    test ${t_estat_arr[0]} -eq 0 &&  # builtin echo
    test ${t_estat_arr[1]} -eq 0 &&  # tail
    test ${t_estat_arr[2]} -eq 0 &&  # head
    test ${t_estat_arr[3]} -eq 0 &&  # $chop_pid_command
    test ${t_estat_arr[4]} -eq 0 &&  # while loop
    test ${t_estat_arr[5]} -eq 0 &&  # $maybe_sort_command
    test ${t_estat_arr[6]} -eq 0 ||  # ${PROG_COLUMN}
    {
        printf "${PROG} (error): was error while processing output of 'screen -ls' command; PIPESTATUS: %s %s %s %s %s %s; bailing out\n" "${t_estat_arr[@]}" 1>&2
        exit 1
    }

else

    # Note that our bash regexen below keep all tokens of the session name (it
    # may contain spaces; see notes above) by definitively matching the date
    # and session state tokens at the end of each line of 'screen -ls' output,
    # and then keeping everything that appears in front of them.

    builtin echo "${DATA_SCREEN_LS_OUTPUT}" \
    | grep '^[[:space:]]\{1,\}[^[:space:]]' \
    | $chop_pid_command \
    | while read -r line; do

          : $PROG \(trace: $LINENO\): line: "$line"

          if test -z "${re_chunks}"; then

              # CAREFUL: Order of the regex tests is important
              #
              if   [[ "$line" =~ $re_chunks_type_010 ]]; then
                  re_chunks=$re_chunks_type_010

              elif [[ "$line" =~ $re_chunks_type_005 ]]; then
                  re_chunks=$re_chunks_type_005

              else
                  printf "${PROG} (error): unrecognized output from 'screen -ls':\n    \"%s\"\nBailing out\n" "$line" 1>&2
                  exit 1  # from subshell
              fi
          else
              if [[ "$line" =~ $re_chunks ]]; then :; else
                  printf "${PROG} (error): unrecognized output from 'screen -ls':\n    \"%s\"\nBailing out\n" "$line" 1>&2
                  exit 1  # from subshell
              fi
          fi

          t_session_name=${BASH_REMATCH[1]}   # may contain spaces
          # t_session_date=${BASH_REMATCH[2]}   # will be empty if output is from an older version of screen
          # t_session_state=${BASH_REMATCH[3]}  # '(Attached)', '(Detached)', ...

          printf '%s\n' "${t_session_name}"
      done \
    | $maybe_sort_command

    # See notes above on why we can't use bash's 'pipefail' option, etc.

    declare -a t_estat_arr=( ${PIPESTATUS[@]} )

    test ${t_estat_arr[0]} -eq 0 &&  # builtin echo
    test ${t_estat_arr[1]} -eq 0 &&  # grep
    test ${t_estat_arr[2]} -eq 0 &&  # $chop_pid_command
    test ${t_estat_arr[3]} -eq 0 &&  # while loop
    test ${t_estat_arr[4]} -eq 0 ||  # $maybe_sort_command
    {
        printf "${PROG} (error): was error while processing output of 'screen -ls' command; PIPESTATUS: %s %s %s %s %s; bailing out\n" "${t_estat_arr[@]}" 1>&2
        exit 1
    }

fi

exit 0


# ----------------------------------------------------------------------------
# Documentation
#
# The docs are in Perl's POD format, so you can run either the 'perldoc' or
# 'pod2man' programs on this file to produce a man page.
#
# To generate a man page for distribution (in a tarball, DEB, or RPM, for
# instance), you'll probably want to run pod2man something like this:
#
#     $ pod2man /path/to/this/file \
#               --center='screen-ls' \
#               --release='screen-wrappers-0.1.0' \
#               --section='1' \
#               > /outputdir/screen-ls.1
#
# To inspect the page formatting, etc., you can pipe the above 'pod2man'
# command to:
#     'man -l -'
# instead of redirecting the output to a file.
#
# ----------------------------------------------------------------------------

=pod

=head1 NAME

  screen-ls - pretty-prints the output from 'screen -ls'


=head1 SYNOPSIS

  screen-ls -h
  screen-ls -V
  screen-ls [OPTION...] [--] [SCREEN_OPTIONS]


=head1 DESCRIPTION

The C<screen-ls> program invokes the GNU L<screen(1)> program with the C<-ls>
option to obtain a list of screen session names, and pretty prints the
output. See L</"EXAMPLES"> below.

By default, prints the L<screen(1)> session names (without the leading pid and
C<.> char) from the output of the C<screen -ls> command.

With the C<-l> (C<--long>) option, will print the full output in a readable
table.

With the C<-p> (C<--show-pid>) option, will include the pid and <.> char which
are suppressed by default.

Any options not recognized by C<screen-ls> will be passed through to
L<screen(1)>. You can explicitly stop C<screen-ls> options processing by using
the C<--> pseudo-option; all options after that will be passed through to
L<screen(1)>.


=head2 Motivation

When working with GNU L<screen(1)>, it is not uncommon to accumulate a large
number of L<screen(1)> sessions. This naturally leads to the need to locate
"interesting" sessions at a later time when you wish to reconnect to them.
And that, of course, becomes more difficult as the number of L<screen(1)>
sessions increases.

Pretty-printing the output makes it easier to read by inspection, and
suppressing everything except the L<screen(1)> session names from the output
often simplifies downstream processing in a Unix pipeline.


=head1 OPTIONS

Below are the command line options recognized by C<screen-ls>. Any options not
recognized by C<screen-ls> will be passed through to the L<screen(1)>
subprocess.

You can explicitly stop C<screen-ls> options processing by using the C<-->
pseudo-option; all options after that will be passed through to L<screen(1)>.


=over 4

=item -h, --help

Print help usage message


=item -l, --long

Use a long listing format.


=item -p, --show-pid

Causes C<screen-ls> to display the '<pid>.' prefix in screen session names. By
default, C<screen-ls> suppresses the output of this prefix.


=item -U, --unsorted

Do not sort output; list L<screen(1)> sessions in order output by the C<screen
-ls> subprocess invocation.

By default, C<screen-ls> sorts the output by L<screen(1)> session name; this
is an optimization for the common case. Prior to this behavior, the most
common invocation of C<screen-ls> was:

    $ screen-ls | sort

The C<-U> (C<--unsorted>) option exists to allow you to disable this behavior,
though.


=item -V, --version

Print the version of the program to stdout and then exit.


=item -v, --verbose

Turn on verbose mode. Two or more -v options turns on tracing (invokes C<set
-x>; this is primarily intended for developers).


=back


=head1 EXAMPLES


For reference, the default output of C<screen -ls> might look like this:

    $ screen -ls
    There are screens on:
        779.screen-wrappers-dev (07/08/2013 01:09:19 PM)        (Attached)
        26043.datomic-local     (07/07/2013 02:20:50 PM)        (Attached)
        14926.emacs-dev (06/30/2013 07:57:14 PM)        (Attached)
        24078.activemq-mysql-prod       (06/23/2013 01:22:41 AM)        (Detached)
        803.build-build (05/22/2013 06:02:49 AM)        (Detached)
        12522.release-5.5       (05/18/2013 06:09:31 AM)        (Attached)
        5200.mutt      (05/17/2013 10:21:59 AM)        (Attached)
    ...
    49 Sockets in /var/run/screen/S-ads.

That output is truncated, but you get the idea. When there are only two or
three L<screen(1)> session active, then the default output works
fine. However, when there are a large number of L<screen(1)> sessions active
(such as in above example, where there are 49), it can become difficult to
find the interesting ones. Enter C<screen-ls>.

By default, C<screen-ls> strips away all data except the L<screen(1)> session
name, and it removes the pid and following C<.> character from those, as
well. Here is how the above output appears when generated by C<screen-ls>:

    $ screen-ls
    activemq-mysql-prod
    build-build
    datomic-local
    emacs-dev
    mutt
    release-5.5
    screen-wrappers-dev
    ...

That is both easier to read, and easier to process by downstream tools in a
pipeline.

Note that C<screen-ls> sorted the output by the L<screen(1)> session name
automatically. You can disable the sorting behavior by providing the C<-U>
(C<--unsorted>) option:

    $ screen-ls -U
    screen-wrappers-dev
    datomic-local
    emacs-dev
    activemq-mysql-prod
    build-build
    release-5.5
    mutt
    ...


An example of common usage in a pipeline is to use C<screen-ls> to find a given
L<screen(1)> session, and then use the shell's command recall and command line
editing facilities to feed that found L<screen(1)> session name to
L<screen(1)> in order to reconnect to it. Using our running example, let's say
we want to reconnect to the L<screen(1)> session in which emacs development is
underway. In a POSIX compatible shell, that can be accomplished thus:

    $ screen-ls | grep emacs
    emacs-dev

    $ screen -d -r $(screen-ls | grep emacs)

Using L<bash(1)>, the keystrokes required for that invocation on the author's
machine are:

    s c r TAB - l TAB | g r e p SPACE e m a c s RET

    C-p C-a s c r TAB - d SPACE - r SPACE $ ( C-e ) RET

While that may be tedious to read, it flies off the fingers. Compare that to
accomplishing the same task reliably without C<screen-ls>.

If you have duplicate session names, in order to reconnect to a particular
L<screen(1)> session you will need to specify the C<pid> prefix for the
session name that C<screen-ls> suppresses by default. You can prevent
C<screen-ls> from suppressing this behavior by specifying the C<-p>
(C<--show-pid>) option:

    $ screen-ls -p -U
    779.screen-wrappers-dev
    713.screen-wrappers-dev
    26043.datomic-local
    14926.emacs-dev
    24078.activemq-mysql-prod
    803.build-build
    12522.release-5.5
    5200.mutt
    ...

    $ screen -d -r 713.screen-wrappers-dev


When invoked with the C<-l> (C<--long>) option, C<screen-ls> will print the
C<screen ls> output in a readable table (still sorted by L<screen(1)> session
name):

    $ screen-ls -l
    activemq-mysql-prod  (06/23/2013 01:22:41 AM)  (Detached)
    build-build          (05/22/2013 06:02:49 AM)  (Detached)
    datomic-local        (07/07/2013 02:20:50 PM)  (Attached)
    emacs-dev            (06/30/2013 07:57:14 PM)  (Attached)
    mutt                 (05/17/2013 10:21:59 AM)  (Attached)
    release-5.5          (05/18/2013 06:09:31 AM)  (Attached)
    screen-wrappers-dev  (07/08/2013 01:09:19 PM)  (Attached)
    ...


Of course, to see the C<pid> prefixes on the session names, you would need to
add the C<-p> option to that:

    $ screen-ls -l -p
    24078.activemq-mysql-prod  (06/23/2013 01:22:41 AM)  (Detached)
    803.build-build            (05/22/2013 06:02:49 AM)  (Detached)
    26043.datomic-local        (07/07/2013 02:20:50 PM)  (Attached)
    14926.emacs-dev            (06/30/2013 07:57:14 PM)  (Attached)
    5200.mutt                  (05/17/2013 10:21:59 AM)  (Attached)
    12522.release-5.5          (05/18/2013 06:09:31 AM)  (Attached)
    779.screen-wrappers-dev    (07/08/2013 01:09:19 PM)  (Attached)
    ...

Note that the output is still sorted by the L<screen(1)> session name (as it
exists without the '<pid>.' prefix, the same way you would see it within
L<screen(1)> when output via screen's C<sessionname> command).


=head1 DIAGNOSTICS

Exits with 0 (zero) status on success, nonzero on error.


=head1 BUGS

=over

=item *

Internally checks that the exit status of C<screen -ls> is 1 when it detects
that the underlying C<screen> version is older than C<4.0.3> (released
2015-06-12, advertized as C<4.03.00> by C<screen --version>). Those older
versions have a bug that causes the C<screen -ls> command to exit with status
1 upon success even when existing screen sessions are detected.

For info on the upstream bug see:

    <http://savannah.gnu.org/bugs/?26750>

See comments in C<screen-ls> source code for more details (HINT: grep for
C<SCREEN_LS_ESTAT>).

=back

If you find any others, please send a bug report to the author. See
L</"AUTHOR">


=head1 AUTHOR

Written by Alan D. Salewski <salewski@att.net>.


=head1 CONTRIBUTORS

    John Marquart (jomarqua@gmail.com)


=cut

# Copyright symbol gets munged by pod2man(1), so we'll fall back on using '(C)'
# Copyright © 2013, 2016, 2017, 2019 Alan D. Salewski <salewski@att.net>

=pod 

=head1 COPYLEFT

Copyright (C) 2013, 2016, 2017, 2019 Alan D. Salewski <salewski@att.net>

License GPLv2+: GNU GPL version 2 or later <http://gnu.org/licenses/gpl.html>.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

=cut


# Local Variables:
#     mode: sh
#     eval: (sh-set-shell "bash" t nil)
# End:
